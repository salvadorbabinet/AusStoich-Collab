---
title: "Analysis of Root and Soil Data - Ch. 2"
author: "Caroline Dallstream"
output: html_document
---

Last updated on 2024-1-18. Individual data files contain dates to track versions. 

**To do:** 

*try MYC~Mg with varIdent structure?
* GAMM for D?



# Introduction

Data were collected for the second chapter of my thesis exploring fine-root responses to soil heterogeneity and determining meaningful spatial scales for their variation. Handroanthus ochraceus was sampled along a fertility gradient. Field work was performed in Guanacaste, Costa Rica, in Horizontes (H), Santa Rosa (S), and Palo Verde (P) from June-July 2022. Three root systems were sampled on 10 individual trees in the three sites (N=90). Soil samples were collected adjacent to 3 root samples per tree and pooled. Some soil samples were additionally pooled between 2 individual trees within each site (for texture, P fractions).  

This script will work on collated data output from "root_soil_data_collation.Rmd" and conduct statistical analyses. 

*Note*: I was getting errors (unused argument in 'select' function, it was not recognizing columns). This was because the MASS package is loaded (which has its own select function), which R was defaulting too. To fix the error, I had to specify dplyr::select() in the code.

# Environment Set-Up

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

setwd("C:/Users/csdal/Documents/McGill/Thesis/Ch.2 - fine root spatial variation and drivers/Ch.2_data_and_analyses")

# R.version
# citation() ## for R in general
# citation("vegan")
# citation("nlme")
# citation("FactoMineR")
# citation("PNWColors")

```

```{r, include = FALSE}

library(tidyverse)
# library(gridExtra) 
# library(knitr) 
library(vegan)
library(factoextra) 
library(FactoMineR) 
# library(corrplot)
# library(MASS) 
library(MuMIn)
library(nlme) 
library(lme4) 
library(ape)
library(GGally)
library(PNWColors)
library(BiodiversityR)
library(ggrepel)
library(broom)
library("ggpubr")

theme_set(theme_bw())

# color palette for sites
pal <- PNWColors::pnw_palette(name = "Bay", type = "discrete")
pal3 <- pal[c(2, 4, 5)] # for sites

# color palette for variance partitioning/sampling scales
pal.var.full <- PNWColors::pnw_palette(name = "Lake", type = "discrete")
pal.var.3 <- pal.var.full[c(2, 4, 6)]

# color palette for rda
shuksan <- pnw_palette(name = "Shuksan", type = "discrete")
s1 <- shuksan[1]
s2 <- shuksan[3]

# color palette for P fraction plot
cascades <- pnw_palette("Cascades")

```

## Load and Prep Data

```{r, include=FALSE}

# read in data, assign factors and levels, remove 'ID' column made when csv was written

soil <- read_csv("data/collated_soil_2023-04-19.csv")

soil <- soil %>% 
  mutate(site = factor(site, levels = c("H", "S", "P")),
         tree = factor(tree)) %>%
  mutate(N_inorg = mg_N.NO3_kg_dry_soil_final + mg_N.NH4_kg_dry_soil) %>%
  mutate(mg_N.NO3_kg_dry_soil_final = mg_N.NO3_kg_dry_soil_final + 0.001) %>%
  select(-c(1))

root <- read_csv("data/collated_roots_2024-1-11.csv") %>%
  select(-1)

root <- root %>% 
  mutate(site = factor(site, levels = c("H", "S", "P")),
         tree = factor(tree),
         root = factor(root)) 

DBH <- read_csv("data/sample-locations_2022-07-09.csv") %>%
  select(site, tree, root, DBH_cm) %>% 
  mutate(site = factor(site, levels = c("H", "S", "P")),
         tree = factor(tree),
         root = factor(root))


dbh <- DBH %>%
  group_by(site, tree) %>%
  summarise(., DBH_cm = mean(DBH_cm)) %>%
  ungroup()

# average roots by tree, then join with soil (n = 30)

all <- root %>%
  group_by(site, tree) %>%
  summarize(across(umol_pNP_g_h:RBI_t_cm, ~mean(.x))) %>%
  ungroup() %>%
  left_join(., soil, by = c("site", "tree")) %>%
  left_join(., dbh, by = c("site", "tree")) %>%
  relocate(., DBH_cm, .after = tree)
  

pfrac <- read_csv("data/soil_texture_Pfractions_2022-08-23.csv")


```


## Set up data frame for multivariate analyses
Remove variables from soil that are applied across sites (e.g., texture, P fractions). Remove undesired environmental variables (ecologically important ones, e.g., GWC, or that are likely to be very collinear, e.g., CEC and individual cations) before proceeding with multivariate analyses. 

```{r}

# GGpairs of all key root traits

# root_short <- root %>%
#   select(-c(V_mm3, SA_mm2, L_mm, tips, C_percent))
#   
# pairs.root <- ggpairs(root_short %>% select(-c(tree, root)), progress = FALSE)
# png("output/ggpairs-roots_2024-1-18.png", height = 14, width = 14, unit = "in", res = 800)
# print(pairs.root)
# dev.off()

# select key soil variables 

soil_short <- soil %>%
  dplyr::select(-c(depth_cm, 
            `acidity_saturation_%`, exchangeable_acidity_cmol_kg,
            CEC_cmol_kg, 
            N_inorg, 
            `gwc_g_g-1_fresh_soil`, 
            Pi_NaHCO3_m, Po_NaHCO3_m, Pi_NaOH_m,
            Po_NaOH_m, Pi_HCl_m, P_residual_m, P_fractions_sum_m,
            sand_m, silt_m, clay_m)) 

soil_samp <- soil %>%
  select(site, tree)

# GGpairs of key soil variables

# pairs.soil <- ggpairs(soil_short %>% select(-c(tree)), progress = FALSE)
# png("output/ggpairs-soil_2024-1-18.png", height = 14, width = 14, unit = "in", res = 800)
# print(pairs.soil)
# dev.off()

# separate variables and sample IDs into 2 datasets for multivariate analyses

soil_var <- soil_short %>%
  dplyr::select(-c(site, tree)) 

## prepare root data

root_var <- root %>%
  dplyr::select(c(D_mm, SRL_m_g, resp_ug_g_min, umol_pNP_g_h, 
                  RTD_g_cm3, myc_percent, N_percent, RBI_t_cm, 
                  firstorder_mm)) 

# make nicer label names for graphing

root_var_r <- root_var %>%
  rename(Diameter = D_mm,
         `Specific Root Length` = SRL_m_g,
         `Respiration Rate` = resp_ug_g_min,
         `Phosphatase Activity` = umol_pNP_g_h,
         `Tissue Density` = RTD_g_cm3,
         `Mycorrhizal Colonization` = myc_percent,
         `N%` = N_percent,
         `Branching Intensity` = RBI_t_cm,
         `First Order Length` = firstorder_mm) 

root_samp <- root %>%
  select(site, tree, root) 



# do the same for all (roots averaged to tree level)

root_var.30 <- all %>%
  dplyr::select(c(D_mm, SRL_m_g, resp_ug_g_min, umol_pNP_g_h, 
                  RTD_g_cm3, myc_percent, N_percent, RBI_t_cm, 
                  firstorder_mm)) 


# corrplot(cor(soil_var), method = "ellipse", type = "upper", tl.cex = 0.9)


```


## Prepare for multivariate analysis: center, scale, normalize
```{r}

### SOILS 

# GGally::ggpairs(soil_var)

# with individual cations, NO3, NH4
# pH, P, Ca, Mg, GWC, NH4, NO3 are non-normal (right skewed)
# log transform and remove original variables
# soil C and N are highly correlated (R2=0.94), so remove soil C%

soil_var.2 <- soil_var %>%
  mutate(pH_log = log(pH_H2O),
         P_log = log(P_mg_kg),
         Ca_log = log(Ca_cmol_kg),
         Mg_log = log(Mg_cmol_kg),
         GWC_log = log(`gwc_g_g-1_dry_soil`),
         NO3_log = log(mg_N.NO3_kg_dry_soil_final),
         NH4_log = log(mg_N.NH4_kg_dry_soil)) %>%
    ## remove untransformed variables
  select(-c(pH_H2O, P_mg_kg, Ca_cmol_kg, Mg_cmol_kg, `gwc_g_g-1_dry_soil`, mg_N.NO3_kg_dry_soil_final,    mg_N.NH4_kg_dry_soil,`C_%`)) %>%
  rename(pH = pH_log,
         PO4 = P_log,
         Ca = Ca_log,
         Mg = Mg_log,
         K = K_cmol_kg,
         GWC = GWC_log,
         NO3 = NO3_log,
         NH4 = NH4_log,
         `N%` = `N_%`,
         `Bulk Density` = `bulk_den_g_cm-3`)

# check that variables are normal and no variables look highly collinear

# ggpairs(soil_var.2)

# center and scale data ("standardize") to mean 0 and variance 1

soil_var.2 <- decostand(soil_var.2, "standardize")

### ROOTS

# ggpairs(root_var)

# SRL, RESP, PME are non-normal (log transform and remove)
# first order length is highly related to SRL

root_var.2 <- root_var %>%
  mutate(SRL_log = log(SRL_m_g),
         RESP_log = log(resp_ug_g_min),
         PME_log = log(umol_pNP_g_h)) %>%
  select(-c(SRL_m_g, resp_ug_g_min, umol_pNP_g_h, firstorder_mm)) %>%
  rename(D = D_mm,
         SRL = SRL_log,
         RESP = RESP_log,
         PME = PME_log,
         RTD = RTD_g_cm3,
         `AM%` = myc_percent,
         `N%` = N_percent,
         `RBI` = RBI_t_cm) 

root_var.2 <- decostand(root_var.2, "standardize")

pairs.root <-ggpairs(root_var.2)

## average roots to tree level for RDA

root_var.2.30 <- root %>%
  dplyr::select(c(site, tree, root, D_mm, SRL_m_g, resp_ug_g_min, umol_pNP_g_h, 
                  RTD_g_cm3, myc_percent, N_percent, RBI_t_cm)) %>%
  mutate(SRL_log = log(SRL_m_g),
         RESP_log = log(resp_ug_g_min),
         PME_log = log(umol_pNP_g_h)) %>%
  select(-c(SRL_m_g, resp_ug_g_min, umol_pNP_g_h)) %>%
  group_by(site, tree) %>%
  summarize_if(is.numeric, mean) %>%
  ungroup() %>%
  select(-c(site, tree)) %>%
  rename(D = D_mm,
         SRL = SRL_log,
         RESP = RESP_log,
         PME = PME_log,
         RTD = RTD_g_cm3,
         `AM%` = myc_percent,
         `N%` = N_percent,
         `RBI` = RBI_t_cm) 

root_var.2.30 <- decostand(root_var.2.30, "standardize")

  

```


# Summarize site-level variables for tables

## Soil

Note: cmol = 10^-2 moles

```{r}

# calculate mean and sd for each variable by site
# do separately for texture and P fractions (N=15) and
# all other variables (N=30) 

# ...requires a ridiculous amount of pivoting longer and wider...
# pivot_longer so that rows aren't sites, but rather are soil variables
# to start, keep separate rows for mean and sd of each variable

soil_long_15 <- pfrac %>%
   select(-c(tree1, tree2, texture)) %>%
  group_by(site) %>%
  summarize(across(.cols = `sand_%`:P_fractions_sum_mg_kg, 
                   list(mean = mean, sd = sd),
                   .names = "{.col}._{.fn}")) %>%
  ungroup() %>%
  pivot_longer(cols = !site,
               names_to = "stat",       
               values_to = "value") %>% 
        # separate mean and sd into rows
        # list all mean and sd in one column
        # doubles df length
  separate_wider_delim(stat, "._", names = c("variable", "fun")) %>%
        # split row name (stat) into columns
        # for variable and whether mean/sd 
  pivot_wider(names_from = fun, values_from = value) %>%
        # now reduce df length by placing 
        # mean and sd into separate columns
  pivot_wider(names_from = site, values_from = c(mean, sd)) %>%
        # finally, create separate columns of mean/sd for  
        # each site variables are in the rows
  relocate(sd_H, .after = mean_H) %>%
  relocate(sd_S, .after = mean_S) %>%
  relocate(sd_P, .after = mean_P) 



soil_long <- soil %>%
  group_by(site) %>%
  select(site, pH_H2O, `bulk_den_g_cm-3`, `gwc_g_g-1_dry_soil`,
         `C_%`, `N_%`, mg_N.NO3_kg_dry_soil_final, mg_N.NH4_kg_dry_soil,  P_mg_kg, 
         Ca_cmol_kg, Mg_cmol_kg, K_cmol_kg) %>%
    summarize(across(.cols = pH_H2O:K_cmol_kg, list(mean = mean, sd = sd),
                   .names = "{.col}._{.fn}")) %>%
  pivot_longer(cols = !site,
               names_to = "stat",  
               values_to = "value") %>% 
        # separate mean and sd into rows
        # list all mean and sd in one column
        # doubles df length
  separate_wider_delim(stat, "._", names = c("variable", "fun")) %>%
        # split row name (stat) into columns
        # for variable and whether mean/sd 
  pivot_wider(names_from = fun, values_from = value) %>%
        # now reduce df length by placing 
        # mean and sd into separate columns
  pivot_wider(names_from = site, values_from = c(mean, sd)) %>%
        # finally, create separate columns of mean/sd for  
        # each site variables are in the rows
  relocate(sd_H, .after = mean_H) %>%
  relocate(sd_S, .after = mean_S) %>%
  relocate(sd_P, .after = mean_P)
        # rearrange so mean and sd listed by site

# export to csv files

# write.csv(soil_long_15, "output/table_soil_pfrac_text_2024-1-12.csv")
# write.csv(soil_long, "output/table_soil_var_2024-1-12.csv")


rm(soil_long_15, soil_long)

```

## Roots

```{r}


root_long <- root %>%
  select(-c(tree, root, V_mm3, SA_mm2, L_mm, tips, firstorder_mm, C_percent)) %>%
  group_by(site) %>%
    summarize(across(.cols = umol_pNP_g_h:RBI_t_cm, list(mean = mean, sd = sd),
                   .names = "{.col}._{.fn}")) %>%
  pivot_longer(cols = !site,
               names_to = "stat",  
               values_to = "value") %>% 
        # separate mean and sd into rows
        # list all mean and sd in one column
        # doubles df length
  separate_wider_delim(stat, "._", names = c("variable", "fun")) %>%
        # split row name (stat) into columns
        # for variable and whether mean/sd 
  pivot_wider(names_from = fun, values_from = value) %>%
        # now reduce df length by placing 
        # mean and sd into separate columns
  pivot_wider(names_from = site, values_from = c(mean, sd)) %>%
        # finally, create separate columns of mean/sd for  
        # each site variables are in the rows
  relocate(sd_H, .after = mean_H) %>%
  relocate(sd_S, .after = mean_S) %>%
  relocate(sd_P, .after = mean_P)

write.csv(root_long, "output/table_root_var_2024-1-15.csv")

```

# Raw trait line figure

```{r}

root <- root%>% 
  mutate(treeID = as.factor(rep(c(1:30), each = 3)))
  

mean <- root%>% group_by(site)%>%summarise(mean.val=mean(SRL_m_g))

( SRL.fig <- ggplot(data = root %>%
                    group_by(site, tree) %>%
                    mutate(min = min(SRL_m_g)) %>%
                    ungroup() %>%
                    group_by(site) %>%
                    arrange(min, .by_group= T),
                  aes(x = SRL_m_g, y = fct_inorder(treeID),
                  col = site))  +
  geom_line(aes(group = treeID, x = SRL_m_g),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3) +
   scale_alpha_discrete(range = c(0.3, 1)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(SRL~(m~g^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-6, 30)) +
  geom_point(data = mean, aes(x = mean.val, y = -3, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- root%>% group_by(site)%>%summarise(mean.val=mean(resp_ug_g_min))

( RESP.fig <- ggplot(data = root %>%
                    group_by(site, tree) %>%
                    mutate(min = min(resp_ug_g_min)) %>%
                    ungroup() %>%
                    group_by(site) %>%
                    arrange(min, .by_group= T),
                  aes(x = resp_ug_g_min, y = fct_inorder(treeID),
                  col = site))  +
  geom_line(aes(group = treeID, x = resp_ug_g_min),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3) +
   scale_alpha_discrete(range = c(0.3, 1)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(RESP~(~mu~g~CO[2]~g^{-1}~min^{-1}))) +
  ylab("") +
  coord_cartesian(ylim=c(-6, 30)) +
  geom_point(data = mean, aes(x = mean.val, y = -3, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- root%>% group_by(site)%>%summarise(mean.val=mean(umol_pNP_g_h))

( PME.fig <- ggplot(data = root %>%
                    group_by(site, tree) %>%
                    mutate(min = min(umol_pNP_g_h)) %>%
                    ungroup() %>%
                    group_by(site) %>%
                    arrange(min, .by_group= T),
                  aes(x = umol_pNP_g_h, y = fct_inorder(treeID),
                  col = site))  +
  geom_line(aes(group = treeID, x = umol_pNP_g_h),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3) +
   scale_alpha_discrete(range = c(0.3, 1)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(PME~(~mu~g~pNP~g^{-1}~h^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-6, 30)) +
  geom_point(data = mean, aes(x = mean.val, y = -3, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- root%>% group_by(site)%>%summarise(mean.val=mean(myc_percent))

( AM.fig <- ggplot(data = root %>%
                    group_by(site, tree) %>%
                    mutate(min = min(myc_percent)) %>%
                    ungroup() %>%
                    group_by(site) %>%
                    arrange(min, .by_group= T),
                  aes(x = myc_percent, y = fct_inorder(treeID),
                  col = site))  +
  geom_line(aes(group = treeID, x = myc_percent),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3) +
   scale_alpha_discrete(range = c(0.3, 1)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(AM~("%"))) +
  ylab("") +
  coord_cartesian(ylim=c(-6, 30)) +
  geom_point(data = mean, aes(x = mean.val, y = -3, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- root%>% group_by(site)%>%summarise(mean.val=mean(N_percent))

( N.fig <- ggplot(data = root %>%
                    group_by(site, tree) %>%
                    mutate(min = min(N_percent)) %>%
                    ungroup() %>%
                    group_by(site) %>%
                    arrange(min, .by_group= T),
                  aes(x = N_percent, y = fct_inorder(treeID),
                  col = site))  +
  geom_line(aes(group = treeID, x = N_percent),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3) +
   scale_alpha_discrete(range = c(0.3, 1)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(N~("%"))) +
  ylab("")  +
  coord_cartesian(ylim=c(-6, 30)) +
  geom_point(data = mean, aes(x = mean.val, y = -3, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- root%>% group_by(site)%>%summarise(mean.val=mean(RBI_t_cm))

( RBI.fig <- ggplot(data = root %>%
                    group_by(site, tree) %>%
                    mutate(min = min(RBI_t_cm)) %>%
                    ungroup() %>%
                    group_by(site) %>%
                    arrange(min, .by_group= T),
                  aes(x = RBI_t_cm, y = fct_inorder(treeID),
                  col = site))  +
  geom_line(aes(group = treeID, x = RBI_t_cm),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3) +
   scale_alpha_discrete(range = c(0.3, 1)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(RBI~(tips~cm^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-6, 30)) +
  geom_point(data = mean, aes(x = mean.val, y = -3, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- root%>% group_by(site)%>%summarise(mean.val=mean(RTD_g_cm3))

( RTD.fig <- ggplot(data = root %>%
                    group_by(site, tree) %>%
                    mutate(min = min(RTD_g_cm3)) %>%
                    ungroup() %>%
                    group_by(site) %>%
                    arrange(min, .by_group= T),
                  aes(x = RTD_g_cm3, y = fct_inorder(treeID),
                  col = site))  +
  geom_line(aes(group = treeID, x = RTD_g_cm3),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3) +
   scale_alpha_discrete(range = c(0.3, 1)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(RTD~(g~cm^{-3}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-6, 30)) +
  geom_point(data = mean, aes(x = mean.val, y = -3, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- root%>% group_by(site)%>%summarise(mean.val=mean(D_mm)) 

( D.fig <- ggplot(data = root %>%
                    group_by(site, tree) %>%
                    mutate(min = min(D_mm)) %>%
                    ungroup() %>%
                    group_by(site) %>%
                    arrange(min, .by_group= T),
                  aes(x = D_mm, y = fct_inorder(treeID),
                  col = site))  +
  geom_line(aes(group = treeID, x = D_mm),
            orientation = "y", 
            size = 1,
            lineend = "round") +
  scale_color_manual(values = pal3) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(D~(mm)))  +
  ylab("") +
  coord_cartesian(ylim=c(-6, 30)) +
  geom_point(data = mean, aes(x = mean.val, y = -3, 
                                 shape = site, color = site),
               size = 4, alpha = 0.75,
               inherit.aes= F)  )


raw.traits <- ggarrange(PME.fig, RESP.fig, 
          SRL.fig, AM.fig,
          N.fig, RBI.fig,
          RTD.fig, D.fig, 
          ncol = 4, nrow = 2)

# png("output/raw-traits-linefigure.png", height = 4.5, width = 8, unit = "in", res = 800)
# print(raw.traits)
# dev.off()

```

# Raw soil line figure

```{r}

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(mg_N.NO3_kg_dry_soil_final))

( NO3.fig <- ggplot(data = soil,
                  aes(x = mg_N.NO3_kg_dry_soil_final, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = mg_N.NO3_kg_dry_soil_final),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
    scale_x_continuous(labels = scales::label_number(accuracy = 0.1)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(NO[3]~(mg~kg^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(mg_N.NH4_kg_dry_soil))

( NH4.fig <- ggplot(data = soil,
                  aes(x = mg_N.NH4_kg_dry_soil, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = mg_N.NH4_kg_dry_soil),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(NH[4]~(mg~kg^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(P_mg_kg))

( PO4.fig <- ggplot(data = soil,
                  aes(x = P_mg_kg, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = P_mg_kg),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(PO[4]~(mg~kg^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(Mg_cmol_kg))

( Mg.fig <- ggplot(data = soil,
                  aes(x = Mg_cmol_kg, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = Mg_cmol_kg),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(Mg~(cmol~kg^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(Ca_cmol_kg))

( Ca.fig <- ggplot(data = soil,
                  aes(x = Ca_cmol_kg, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = Ca_cmol_kg),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(Ca~(cmol~kg^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(`gwc_g_g-1_dry_soil`))

( GWC.fig <- ggplot(data = soil,
                  aes(x = `gwc_g_g-1_dry_soil`, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = `gwc_g_g-1_dry_soil`),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(GWC~(g~g^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(K_cmol_kg))

( K.fig <- ggplot(data = soil,
                  aes(x = K_cmol_kg, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = K_cmol_kg),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
    scale_x_continuous(labels = scales::label_number(accuracy = 0.1)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(K~(cmol~kg^{-1}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(`bulk_den_g_cm-3`))

( bulk.fig <- ggplot(data = soil,
                  aes(x = `bulk_den_g_cm-3`, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = `bulk_den_g_cm-3`),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab(expression(Bulk~(g~cm^{-3}))) +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(`N_%`))

( N.fig <- ggplot(data = soil,
                  aes(x = `N_%`, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = `N_%`),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab("N (%)") +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

mean <- soil %>% group_by(site)%>%summarise(mean.val=mean(pH_H2O))

( pH.fig <- ggplot(data = soil,
                  aes(x = pH_H2O, y = site,
                  col = site))  +
  geom_line(aes(group = site, x = pH_H2O),
            orientation = "y", 
            size = 1,
            lineend = "round") +
   scale_color_manual(values = pal3)  +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 10)) +
  xlab("pH") +
  ylab("")  +
  coord_cartesian(ylim=c(-1, 3)) +
  geom_point(data = mean, aes(x = mean.val, y = -0.5, 
                                 shape = site, color = site),
               size = 4,  alpha = 0.75,
               inherit.aes= F)  )

soil.line.fig <- ggarrange(NO3.fig, NH4.fig, PO4.fig, Mg.fig, Ca.fig,
          GWC.fig, K.fig, bulk.fig, N.fig, pH.fig,
          ncol = 5, nrow = 2)

ggsave("output/soil_linefig.png", 
       height = 4, width = 8, unit = "in", dpi = 800)
```


# Non-hierarchical cluster analysis (kmeans)

## Soil cluster analysis

Based on notes from Borcard 2018, Chapter 4.

When I standardize data, I get 3 kmeans groups that don't represent sites. Most fall into group 1. 

When I normalize data, I get 5 kmeans groups with H mostly separate, more mixing within the P and S sites. I *think* that I properly extracted the kmeans group assignations (into `kmeans_clusters`). 


```{r}

# run Ward hierarchical clustering to see how many groups are suggested
# then set kmeans to that number? 
# Borcard says if you know how many groups, go straight for kmeans with nstart 

# normalize env'l data ('species' data in the book)
# var.norm <- decostand(soil_var, "normalize")
    ## this approach was an earlier version. tried below with new, simplified 
    ## and normalized dataset

# compare partitions of different group sizes (k=2-10 groups)

# here, soil_var.2 is standardized (not normalized, although distributions near normal)
var.KM.cascade <- vegan::cascadeKM(
  soil_var.2,
  inf.gr = 2,
  sup.gr = 10,
  iter = 500,
  criterion = "ssi")

summary(var.KM.cascade)
plot(var.KM.cascade, sort = F)
  ## use sort = F so sample order is maintained (H, S, P)

###
###

kmeans <- stats::kmeans(soil_var.2, centers = 3, nstart = 100)
    ## run kmeans() on normalized data (check normality!)
    ## 3 'centers' or k groups are chosen
    ## run the analysis 100 times to find optimal grouping (random)

# exctract groupings from kmeans analysis set with 5 groups
soil_clusters <- kmeans$cluster

rm(kmeans, var.norm, var.KM.cascade)


```

## Root cluster analysis

```{r}

# compare partitions of different group sizes (k=2-10 groups)

var.KM.cascade <- vegan::cascadeKM(
  root_var.2,
  inf.gr = 5,
  sup.gr = 15,
  iter = 500,
  criterion = "ssi")

# examine groupings

summary(var.KM.cascade)
plot(var.KM.cascade, sort = F)
  ## use sort = F so sample order is maintained
  ## 10 groupings is best

kmeans <- stats::kmeans(root_var.2, centers = 6, nstart = 100)

root_clusters <- kmeans$cluster

rm(kmeans, var.KM.cascade)

```


# PCA 

## Soil PCA 

Remove any variables that are applied across whole sites (only keep tree-level measurements) to avoid undue influence on unconstrained ordination. remove any variables that are clearly related (e.g., cation exchange capacity instead of Ca, Mg, K, and exchangeable acidity). I will leave collinear variables at this stage, since I am interested in their relationships. 

Based on QCBS vegan notes (https://r.qcbs.ca/workshop09/book-en/learning-objectives.html)
FactoMineR documentation


```{r}

# Make nicer variable labels for visualization

# Perform PCA with FactoMineR 
# visualize with factoextra

soil.pca <- FactoMineR::PCA(soil_var.2)
 
summary(soil.pca)  

  ## unknown scaling for the below plot


soil.pca.plot <- factoextra::fviz_pca_biplot(soil.pca, # PCA object
                axes = c(1, 2), # graph first two PCs
                geom.ind = "point", # display trees as points
                geom.var = c("arrow", "text"), # add arrows and text to variables
                pointsize = 5, # increase size of tree points
                labelsize = 9, # increase graph label font size
                alpha = 0.75, # fade points/ellipses to read better
                habillage = as.factor(soil_samp$site), 
                # habillage = as.factor(soil_clusters),
                addEllipses = TRUE, # draw ellipses around groups (sites)
                ellipse.level = 0.95,
                palette = pal3, # match palette with other plots
                col.var = "black", # make arrows/text of var black
                repel = TRUE, # avoid label overlap
                mean.point = FALSE) + # remove site average point
        theme(panel.grid = element_blank(),
        legend.title = element_blank()) +
  theme(text = element_text(size = 17),
        axis.title = element_text(size = 22),
        axis.text = element_text(size = 22),
        title = element_blank()) 

soil.pca.plot

soil.pca.plot.2.3 <- factoextra::fviz_pca_biplot(soil.pca, # PCA object
                axes = c(2, 3), # graph first two PCs
                geom.ind = "point", # display trees as points
                geom.var = c("arrow", "text"), # add arrows and text to variables
                pointsize = 5, # increase size of tree points
                labelsize = 9, # increase graph label font size
                alpha = 0.75, # fade points/ellipses to read better
                habillage = as.factor(soil_samp$site), 
                # habillage = as.factor(soil_clusters),
                addEllipses = TRUE, # draw ellipses around groups (sites)
                ellipse.level = 0.95,
                palette = pal3, # match palette with other plots
                col.var = "black", # make arrows/text of var black
                repel = TRUE, # avoid label overlap
                mean.point = FALSE) + # remove site average point
        theme(panel.grid = element_blank(),
        legend.title = element_blank()) +
  theme(text = element_text(size = 17),
        axis.title = element_text(size = 22),
        axis.text = element_text(size = 22),
        title = element_blank()) 

soil.pca.plot.2.3

# export plot to output folder

# png("output/soil_PCA_2024-9-11.png", height = 8, width = 12, unit = "in", res = 800)
# print(soil.pca.plot)
# dev.off()

# obtain correlation coefficients between variables and
# PCs, and run a significance test on correlations

FactoMineR::dimdesc(soil.pca, axes = c(1, 2))
    ## all variables are significantly correlated with PCS

## examine variables loadings for PCs
## A reference dashed line is also shown on the barplot. 
## This reference line corresponds to the expected value 
## if the contribution where uniform.

fviz_contrib(soil.pca, choice = "var", axes = 1)
fviz_contrib(soil.pca, choice = "var", axes = 2)
fviz_contrib(soil.pca, choice = "var", axes = 3)  

# rm(soil.pca.plot, soil.pca)

# Kaiser Guttman criteria - select PCs that explain the more than
# the average across all PCs

ev <- soil.pca$eig[ ,1] # select eigenvalues for each variable
barplot(ev)
abline(h = mean(ev), col = "red3")
legend("topright", "Average Eigenvalue", col = "red3")

# useful information down to PC3

```




## Root trait PCA

```{r}

# factoextra and FactoMineR approach

root.pca <- FactoMineR::PCA(root_var.2)
  ## scaling????
summary(root.pca)

## unknown scaling for the below plot, scaling = 3?

(root.pca.plot.1.2 <- fviz_pca_biplot(root.pca, # PCA object
                axes = c(1, 2), # graph first two PCs
            ## unknown how to incorporate/verify distance metric??
                geom.ind = "point", # display trees as points
                geom.var = c("arrow", "text"), # add arrows and text to var
                pointsize = 5,
                labelsize = 9,
                alpha = 0.75,
                habillage = as.factor(root$site), # color points by site
                # habillage = as.factor(root_clusters), # looks fine!
                addEllipses = TRUE, # draw ellipses around groups (sites)
                ellipse.level = 0.95,
                palette = pal3, 
                col.var = "black", # make arrows/text of var black
                repel = TRUE, # avoid label overlap
                mean.point = FALSE) + # remove site average point
  theme(panel.grid = element_blank(),
        legend.title = element_blank(),
        title = element_blank(),
        text = element_text(size = 17),
        axis.title = element_text(size = 22),
        axis.text = element_text(size = 22)) )

    # note Tissue Density is on PC3, RBI on PC2 and strongly on PC3

# export plot as png

png("output/root_pca_2024-9-11.png", height = 8, width = 12, unit = "in", res = 800)
print(root.pca.plot.1.2)
dev.off()

# obtain correlation coefficients between variables and
# PCs, and run a significance test on correlations

FactoMineR::dimdesc(root.pca, axes = c(1, 2))
    ## all variables are significantly correlated with PCS


## examine variables loadings for PCs
fviz_contrib(root.pca, choice = "var", axes = 1)
fviz_contrib(root.pca, choice = "var", axes = 2)
fviz_contrib(root.pca, choice = "var", axes = 3) 

# Kaiser Guttman criteria - select PCs that explain the more than
# the average across all PCs

ev <- root.pca$eig[ ,1] # select eigenvalues for each variable
barplot(ev)
abline(h = mean(ev), col = "red3")
legend("topright", "Average Eigenvalue", col = "red3")

# useful information down to PC3


```

## Root trait PCA - reduced collinearity

```{r}

# factoextra and FactoMineR approach

root_var.2.reduced <- root_var.2 %>% select(-c(D))

root.pca.red <- FactoMineR::PCA(root_var.2.reduced)
  ## scaling????
summary(root.pca.red)

## unknown scaling for the below plot, scaling = 3?

(root.pca.red.plot.1.2 <- fviz_pca_biplot(root.pca.red, # PCA object
                axes = c(1, 2), # graph first two PCs
            ## unknown how to incorporate/verify distance metric??
                geom.ind = "point", # display trees as points
                geom.var = c("arrow", "text"), # add arrows and text to var
                pointsize = 5,
                labelsize = 9,
                alpha = 0.75,
                habillage = as.factor(root$site), # color points by site
                # habillage = as.factor(root_clusters), # looks fine!
                addEllipses = TRUE, # draw ellipses around groups (sites)
                ellipse.level = 0.95,
                palette = pal3, 
                col.var = "black", # make arrows/text of var black
                repel = TRUE, # avoid label overlap
                mean.point = FALSE) + # remove site average point
    geom_text(aes(x = -5, y = 3), label = "Roots", size = 10) +
  theme(panel.grid = element_blank(),
        legend.title = element_blank(),
        title = element_blank(),
        text = element_text(size = 17),
        axis.title = element_text(size = 17),
        axis.text = element_text(size = 17)) )

    # note Tissue Density is on PC3, RBI on PC2 and strongly on PC3

# export plot as png

# png("output/root_pca_2024-1-18.png", height = 8, width = 12, unit = "in", res = 800)
# print(root.pca.plot.1.2)
# dev.off()

# obtain correlation coefficients between variables and
# PCs, and run a significance test on correlations

FactoMineR::dimdesc(root.pca.red, axes = c(1, 2))
    ## all variables are significantly correlated with PCS


## examine variables loadings for PCs
fviz_contrib(root.pca.red, choice = "var", axes = 1)
fviz_contrib(root.pca.red, choice = "var", axes = 2)
fviz_contrib(root.pca.red, choice = "var", axes = 3) 

# Kaiser Guttman criteria - select PCs that explain the more than
# the average across all PCs

ev <- root.pca.red$eig[ ,1] # select eigenvalues for each variable
barplot(ev)
abline(h = mean(ev), col = "red3")
legend("topright", "Average Eigenvalue", col = "red3")

# useful information down to PC3


```

# RDA to explain soil impacts on root traits

Both matrices (explanatory, response) need to be centered, standardized (if variables are in very different units), and either transformed (to minimize skew, e.g., in species counts) or normalized (for linear relationships). Collinearity between explanatory variables should be reduced.

## RDA with forward selection (no RTD or RBI)

```{r}

# try a forward selection
# QCBS tutorial warns that ecologically informed decisions are favored over
# forward selection, but I am trying it out.

  ### SCALING 1 = distance triplot. angles btwn response and explan. var. in
  ### triplot reflect their correlations 
  ###
  ### **SCALING 2** = correlation triplot. projecting an obj at right angles onto
  ### response or explan. var. approximates their value. angles btwn response
  ### and explan. var. AND btwn response var. themselves AND btwn explan. var. 
  ### themselves reflect their correlations!
  ### distances btwn centroids/objects do NOT approximate Euclidean distances

root.rda <- vegan::rda(root_var.2.30 ~., data = soil_var.2) 

fwd.sel <- ordiR2step(rda(root_var.2.30 ~ 1, data = soil_var.2), # lower model limit (simple!)
               scope = formula(root.rda), # upper model limit (the "full" model)
               direction = "forward",
               R2scope = TRUE, # can't surpass the "full" model's R2
               pstep = 1000,
               trace = TRUE) # change to TRUE to see the selection process!

fwd.sel$call

# the forward selection process found an rda of root traits explained
# by bulk density, CEC, and ammonium was the best model

(root.rda3 <- rda(root_var.2.30 ~ Mg + `Bulk Density`, data = soil_var.2))

summary(root.rda3)

# rda output lacks canonical coef (like a regression coef)
# extract canonical coefficients from rda object
coef(root.rda3)

(AdjR2 <- vegan::RsquareAdj(root.rda3))

# Adj R2 = 0.22

# Global test of RDA result

anova.cca(root.rda3, step = 1000)

# test of each term in the model

anova.cca(root.rda3, 
      by = "term",
      step  = 1000)

# Test of all canonical axes

anova.cca(root.rda3, 
      by = "axis",
      step  = 1000)

# Global model, soil terms, and RDA1 &n RDA2 are significant!
# however, no species (root traits) are 'good'
(root.good <- goodness(root.rda3))

ordiplot(root.rda3, type = "text", scaling = 1)

ordiplot(root.rda3, choices = c(1,2),
         type = "point", scaling = 1) %>%
  points("sites", pch=21, col = "gray", bg="gray") %>%
  text("species", col="red", cex=0.9,  arrows = TRUE, length = 0.05)

vif.cca(root.rda3)


```


## RDA with ecologically informed soil variables - final model

Scaling 1 shows similarities between objects in the response matrix.
-Sites (numbers) that are closer together have more similar communities.
-Species that are closer together occupy more sites in common.

```{r}

# RTD and RBI removed (increased R2 adj without)
# RTD is on 3rd PC, RBI just barely contributes to PC2

root_var.2.30 <- root_var.2.30 %>%
  select(-c(RBI, RTD))

# the forward selection process found an rda of root traits explained
# by bulk density, CEC, and ammonium was the best model

(root.rda.4 <- rda(root_var.2.30 ~ Mg + `Bulk Density` + 
                     PO4 + NH4 , data = soil_var.2))

summary(root.rda.4)

# RDA1 24%, RDA2 14%

# rda output lacks canonical coef (like a regression coef)
# extract canonical coefficients from rda object
coef(root.rda.4)

(AdjR2 <- vegan::RsquareAdj(root.rda.4))

# Adj R2 = 0.31

# Global test of RDA result

anova.cca(root.rda.4, step = 1000)

# test of each term in the model

anova.cca(root.rda.4, 
      by = "term",
      step  = 1000)

# Test of all canonical axes

anova.cca(root.rda.4, 
      by = "axis",
      step  = 1000)

# Global model, soil terms, and RDA1 &n RDA2 are significant!
# however, no species (root traits) are 'good'
(root.good <- goodness(root.rda.4))

vif.cca(root.rda.4)


ordiplot(root.rda.4, choices = c(1,2),
         type = "point", scaling = 1) %>%
  points("sites", pch=21, col = "gray", bg="gray") %>%
  text("species", col="red", cex=0.9,  arrows = TRUE)



```



## Plot with ggplot2 (via BiodiversityR and vegan)

This approach uses vegan::scores() and BiodiversityR::axis.long(). Using scaling = "species" A.K.A. scaling = 2 (scaling performed on root traits). Using correlation = FALSE since data were standardized previously. 

A full BiodiversityR approach uses ordiplot(), sites.long(), species.long(), and axis.long() but also needs a separate extraction of biplot scores with vegan::scores(). 

```{r}

scores <- vegan::scores(root.rda.4, 
                        choices = c(1,2), 
                        tidy = TRUE,
                        scaling = "species",
                        correlation = FALSE)

# extract each tree's scores "sites"
  ## also, re-add site information to color in graph

tree.scores <- scores %>%
  filter(score == "sites") %>%
  mutate(site = soil_samp$site)

# extract root data "species"

root.scores <- scores %>%
  filter(score == "species")

# extract soil variables scores (no scaling - doesn't seem to change)

soil.scores <- scores %>%  
    filter(score == "biplot") %>%
    mutate(label = if_else(label == "`Bulk Density`", "Bulk Density", label))
        ## just removing the quotes from Bulk Den from graph

# extract axis information (RDA% variation)

axis.long <- BiodiversityR::axis.long(root.rda.4, choices=c(1, 2))


# plot

tree.scores <- tree.scores %>%
  mutate(site = case_when(site == "H" ~ "Horizontes",
                          site == "S" ~ "Santa Rosa",
                          site == "P" ~ "Palo Verde")) %>%
  rename(Site = site) %>%
  mutate(Site = factor(Site, levels = c("Horizontes", "Santa Rosa", "Palo Verde")))



rda.plot <- ggplot() + 
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axis.long[1, "label"]) +
    ylab(axis.long[2, "label"]) +
    geom_point(data=tree.scores,
               aes(x=RDA1, y=RDA2, shape = Site, color = Site), 
               size=4, alpha = 0.8) +
    scale_color_manual(values = pal3) +
    geom_segment(data=root.scores, 
                 aes(x=0, y=0, xend=RDA1*3, yend=RDA2*3), 
                 colour= "#4a9152", linewidth=0.8, arrow=arrow()) +
                    ## multiply all values by 4 for better visualization
    geom_text_repel(data=root.scores, 
                    aes(x=RDA1*3.5, y=RDA2*3.5, label=label),
                    colour="#4a9152",
                    size = 9) +
                    ## multiply text positions by 4.5 to avoid overlap with arrows
    geom_segment(data=soil.scores, 
                 aes(x=0, y=0, xend=RDA1*3, yend=RDA2*3), 
                 colour="#54450f", linewidth=0.8, arrow=arrow()) +
    geom_text_repel(data=soil.scores, 
                    aes(x=RDA1*3.5, y=RDA2*3.5, label=label),
                    colour="#54450f",
                    size = 9) +
    theme_bw() +
    theme(text = element_text(size = 17),
          panel.grid = element_blank()) 

# magenta3 for arrows previously
   
rda.plot

# ggsave("output/rda_graph_2024-8-21.v3.png", rda.plot,
#        width = 12, height = 8, unit = "in", dpi = 800)


```

# Coefficients of variation for roots and soil


```{r}

########
## roots
########

mean <- root_var %>% 
  select(-c(firstorder_mm)) %>%
  rename(Diameter = D_mm, `Mycorrhizal Colonization` = myc_percent, `Phosphatase Activity` = umol_pNP_g_h,
         `Respiration Rate` = resp_ug_g_min, `Tissue Density` = RTD_g_cm3, `Specific Root Length` = SRL_m_g,
         `Root Branching Intensity` = RBI_t_cm, `N Concentration` = N_percent) %>%
  summarise(across(is.numeric, ~mean(.))) %>%
  pivot_longer(cols = everything(), 
               names_to = "trait", 
               values_to = "mean")

sd <- root_var %>% 
  select(-c(firstorder_mm)) %>%
  rename(Diameter = D_mm, `Mycorrhizal Colonization` = myc_percent, `Phosphatase Activity` = umol_pNP_g_h,
         `Respiration Rate` = resp_ug_g_min, `Tissue Density` = RTD_g_cm3, `Specific Root Length` = SRL_m_g,
         `Root Branching Intensity` = RBI_t_cm, `N Concentration` = N_percent) %>%
  summarise(across(is.numeric, ~sd(.))) %>%
  pivot_longer(cols = everything(), 
               names_to = "trait", 
               values_to = "sd") 

root_cv <- left_join(mean, sd, by = "trait")%>%
  mutate(cv = (sd/mean*100)) %>%
  mutate(cv = round(cv, digits = 0)) %>%
  arrange(desc(cv)) %>%
  mutate(trait = factor(trait, levels = c("Phosphatase Activity", "Respiration Rate", "Specific Root Length", "Mycorrhizal Colonization", "N Concentration", "Branching Intensity", "Tissue Density",  "Diameter")))

root_cv.plot <- ggplot(aes(x=trait, y=0, size = cv), data = root_cv) +
    geom_point(col ="grey") +
    scale_size_continuous() +
  ylim(-0.005, 0.005) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill='transparent', color=NA)) 

# ggsave('output/root_cv_dots.png', root_cv.plot, bg='transparent',
#        height = 1, width = 4, unit = "in", dpi = 800)

########
## soils
########

mean <- soil_var %>% 
  summarise(across(is.numeric, ~mean(.))) %>%
  select(-c(`C_%`)) %>%
    rename(`Olsen P` = P_mg_kg, `Nitrate-N` = mg_N.NO3_kg_dry_soil_final, `Ammonium-N` = mg_N.NH4_kg_dry_soil, N = `N_%`,
         Magnesium = Mg_cmol_kg, Calcium = Ca_cmol_kg, Potassium = K_cmol_kg, 
         `Bulk Density` = `bulk_den_g_cm-3`, `Water Content` = `gwc_g_g-1_dry_soil`,
         pH = pH_H2O) %>%
  pivot_longer(cols = everything(), 
               names_to = "variable", 
               values_to = "mean")

sd <- soil_var %>% 
  summarise(across(is.numeric, ~sd(.))) %>%
  select(-c(`C_%`)) %>%
  rename(`Olsen P` = P_mg_kg, `Nitrate-N` = mg_N.NO3_kg_dry_soil_final, `Ammonium-N` = mg_N.NH4_kg_dry_soil, N = `N_%`,
         Magnesium = Mg_cmol_kg, Calcium = Ca_cmol_kg, Potassium = K_cmol_kg, 
         `Bulk Density` = `bulk_den_g_cm-3`, `Water Content` = `gwc_g_g-1_dry_soil`,
         pH = pH_H2O) %>%
  pivot_longer(cols = everything(), 
               names_to = "variable", 
               values_to = "sd") 

soil_cv <- left_join(mean, sd, by = "variable") %>%
  mutate(cv = round((sd/mean*100), digits = 0)) %>%
  mutate(variable = factor(variable, levels = c("Nitrate-N", "Ammonium-N", "Olsen P", "Magnesium", "Calcium", "Water Content", "Potassium", "Bulk Density", "N", "pH"))) %>%
  arrange(desc(cv)) 

soil_cv.plot <- ggplot(aes(x=variable, y=0, size = cv), data = soil_cv) +
    geom_point(col ="grey") +
    scale_size(range = c(1, 10)) +
  ylim(-0.005, 0.005) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill='transparent', color=NA)) 

# ggsave('output/soil_cv_dots.png', soil_cv.plot, bg='transparent',
#        height = 1, width = 4, unit = "in", dpi = 800)

```


# Root variance partitioning

Messier 2010, Weemstra 2021, (Zuur 2009) approach. 

Random effects model (no explanatory variable) with nested levels. Roots are within trees are within sites. "Within" portion of variance includes variance due to differences among samples of the lowest nested level and error combined. 

## PME

```{r}

# log transforming improves normality
hist(all$umol_pNP_g_h)
hist(log(all$umol_pNP_g_h))

PME_mod <- lme(log(umol_pNP_g_h) ~ 1, data = root, random = ~ 1|site/tree)
summary(PME_mod)

anova(PME_mod)
plot(PME_mod)
E <- residuals(PME_mod)
qqnorm(E)
qqline(E)
hist(E)
plot(E ~ site, data = root)

# extract variance and calculate percentages
# for future reference:
# scale=TRUE calculates % variance automatically

var <- varcomp(PME_mod, scale = TRUE) 

site_PME <- var[1]
tree_PME <- var[2]
root_PME <- var[3]

# save results in dataframe

PME_variance <- data.frame(Ecological_Scale = c("Site", "Tree", "Root + Error"), 
                          PME = c(site_PME, tree_PME, root_PME)) %>%
  as_tibble() %>%
  mutate(PME = round(PME, digits = 2))

# rm(PME_mod, E, var, site_PME, tree_PME, root_PME)

```

## RESP

```{r}

hist(all$resp_ug_g_min)
hist(log(all$resp_ug_g_min))

RESP_mod <- lme(log(resp_ug_g_min) ~ 1, data = root, random = ~ 1|site/tree)
var <- varcomp(RESP_mod, scale = T)

anova(RESP_mod)
plot(RESP_mod)
E <- residuals(RESP_mod)
qqnorm(E)
qqline(E)
hist(E)

# extract variance and calculate percentages
# for future reference:
# scale=TRUE calculates % varaince automatically
 

site_RESP <- var[1]
tree_RESP <- var[2]
root_RESP <- var[3]

# save results in dataframe

RESP_variance <- data.frame(Ecological_Scale = c("Site", "Tree", "Root + Error"),
                   RESP = c(site_RESP, tree_RESP, root_RESP)) %>%
  as_tibble() %>% 
  mutate(RESP = round(RESP, digits = 2))

rm(RESP_mod, E, var, site_RESP, tree_RESP, root_RESP)

```

## SRL

```{r}

hist(all$SRL_m_g)
hist(log(all$SRL_m_g))

SRL_mod <- lme(log(SRL_m_g) ~ 1, data = root, random = ~ 1|site/tree)
anova(SRL_mod)

plot(SRL_mod)
E <- residuals(SRL_mod)
qqnorm(E)
qqline(E)
hist(E)

# extract variance and calculate percentages
# for future reference:
# scale=TRUE calculates % varaince automatically
var <- varcomp(SRL_mod, scale = TRUE) 

site_SRL <- var[1]
tree_SRL <- var[2]
root_SRL <- var[3]

SRL_variance <- data.frame(Ecological_Scale = c("Site", "Tree", "Root + Error"), 
                           SRL = c(site_SRL, tree_SRL, root_SRL)) %>%
  as_tibble() %>%
  mutate(SRL = round(SRL, digits = 2))

rm(SRL_mod, E, var, site_SRL, tree_SRL, root_SRL)

```

## D 

```{r}

hist(all$D_mm)
hist(log(all$D_mm))

D_mod <- lme(D_mm ~ 1, data = root, random = ~ 1|site/tree)
anova(D_mod)

plot(D_mod)
E <- residuals(D_mod)
qqnorm(E)
qqline(E)
hist(E)

# extract variance and calculate percentages
# for future reference:
# scale=TRUE calculates % varaince automatically
var <- varcomp(D_mod, scale = TRUE) 

site_D <- var[1]
tree_D <- var[2]
root_D <- var[3]

# sum = 1

# save results in dataframe
D_variance <- data.frame(Ecological_Scale = c("Site", "Tree", "Root + Error"), 
                          D = c(site_D, tree_D, root_D)) %>%
  as_tibble() %>%
  mutate(D = round(D, digits = 2))

rm(D_mod, E, var, site_D, tree_D, root_D)

```


## AM%

```{r}

hist(all$myc_percent)
hist(log(all$myc_percent))

MYC_mod <- lme(myc_percent ~ 1, data = root, random = ~ 1|site/tree)
anova(MYC_mod)

plot(MYC_mod)
E <- residuals(MYC_mod)
qqnorm(E)
qqline(E)
hist(E)

# extract variance and calculate percentages
# for future reference:
# scale=TRUE calculates % varaince automatically
var <- varcomp(MYC_mod, scale = TRUE) 

site_MYC <- var[1]
tree_MYC <- var[2]
root_MYC <- var[3]

# sum = 1

# save results in dataframe
MYC_variance <- data.frame(Ecological_Scale = c("Site", "Tree", "Root + Error"), 
                          MYC = c(site_MYC, tree_MYC, root_MYC)) %>%
  as_tibble() %>%
  mutate(MYC = round(MYC, digits =2))

rm(MYC_mod, E, var, site_MYC, tree_MYC, root_MYC)

```


## RTD

```{r}

RTD_mod <- lme(RTD_g_cm3 ~ 1, data = root, random = ~ 1|site/tree)

anova(RTD_mod)
summary(RTD_mod)
plot(RTD_mod)
E <- residuals(RTD_mod)
qqnorm(E)
qqline(E)
hist(E)

# extract variance and calculate percentages
# for future reference:
# scale=TRUE calculates % varaince automatically
var <- varcomp(RTD_mod, scale = TRUE) 

site_RTD <- var[1]
tree_RTD <- var[2]
root_RTD <- var[3]

# sum = 1

# save results in dataframe
RTD_variance <- data.frame(Ecological_Scale = c("Site", "Tree", "Root + Error"), 
                          RTD = c(site_RTD, tree_RTD, root_RTD))      %>%
  as_tibble() %>%
  mutate(RTD = round(RTD, digits =2))

rm(RTD_mod, E, var, site_RTD, tree_RTD, root_RTD)

```

## RBI

```{r}

hist(all$RBI_t_cm)
hist(log(all$RBI_t_cm))

RBI_mod <- lme(RBI_t_cm ~ 1, data = root, random = ~ 1|site/tree)

anova(RBI_mod)
summary(RBI_mod)
plot(RBI_mod)
E <- residuals(RBI_mod)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(RBI_mod, scale = TRUE) 

site_RBI <- var[1]
tree_RBI <- var[2]
root_RBI <- var[3]

# save results in dataframe
RBI_variance <- data.frame(Ecological_Scale = c("Site", "Tree", "Root + Error"), 
                          RBI = c(site_RBI, tree_RBI, root_RBI))      %>%
  as_tibble() %>%
  mutate(RBI = round(RBI, digits =2))

rm(RBI_mod, E, var, site_RBI, tree_RBI, root_RBI)

```

## N%

```{r}

N_mod <- lme(N_percent ~ 1, data = root, random = ~ 1|site/tree)

anova(N_mod)
summary(N_mod)
plot(N_mod)
E <- residuals(N_mod)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(N_mod, scale = TRUE) 

site_N <- var[1]
tree_N <- var[2]
root_N <- var[3]

# sum = 1

# save results in dataframe
N_variance <- data.frame(Ecological_Scale = c("Site", "Tree", "Root + Error"), 
                          N = c(site_N, tree_N, root_N))      %>%
  as_tibble() %>%
  mutate(N = round(N, digits =2))

rm(N_mod, E, var, site_N, tree_N, root_N)

```

### Combine root variance into table to graph

```{r}

# leaving SRA out of this (similar to SRL)

root_variance <- left_join(D_variance, SRL_variance, by = "Ecological_Scale")
root_variance <- left_join(root_variance, RESP_variance, by = "Ecological_Scale")
root_variance <- left_join(root_variance, PME_variance,by = "Ecological_Scale")
root_variance <- left_join(root_variance,  MYC_variance, by = "Ecological_Scale")
root_variance <- left_join(root_variance, RTD_variance, by = "Ecological_Scale")
root_variance <- left_join(root_variance, RBI_variance, by = "Ecological_Scale")
root_variance <- left_join(root_variance, N_variance, by = "Ecological_Scale")

```

### Plot variances together

See https://www.cedricscherer.com/2021/07/05/a-quick-how-to-on-labelling-bar-graphs-in-ggplot2/ for how to overlay percentage on barplots (of CV%)

```{r}

root_variance <- root_variance %>%
  rename(`AM%` = MYC, `N%` = N)

root_var_long <- pivot_longer(root_variance, cols = 2:9, 
                              names_to = "Trait", values_to = "Variance") %>%
  arrange(Trait) %>%
  mutate(Trait = factor(Trait, levels = c("PME", "RESP", "SRL", "AM%", "N%", "RBI", "RTD",  "D")),
         Ecological_Scale = factor(Ecological_Scale, levels = c("Site", "Tree", "Root + Error"))) 

(root.var.plot <- ggplot(data = root_var_long, aes(x = Trait, y = Variance, fill = Ecological_Scale)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = pal.var.3) +
  theme_minimal()+
    theme(axis.text.x = element_text(size = 16, angle = 45, hjust = 1, vjust = 1),
          axis.title.x = element_blank(),
          legend.position = "none",
          axis.title.y = element_blank(),
          axis.text.y = element_blank()) +
  guides(fill=guide_legend(title="Ecological Scale")) +
    geom_hline(yintercept = 0.5, color = "white", linetype = 5) )

```


# Soil Variance partitioning

## P

```{r}

P_mod <- lme(P_mg_kg ~ 1, data = soil, random = ~ 1|site)

anova(P_mod)
plot(P_mod)
E <- residuals(P_mod)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(P_mod, scale = TRUE) 

site_P <- var[1]
tree_P <- var[2]

# save results in dataframe
P_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"), 
                          Olsen_P = c(site_P, tree_P)) %>%
  as_tibble()

rm(P_mod, E, var, site_P, tree_P)

```


## NO3 

```{r}

NO3_mod <- lme(mg_N.NO3_kg_dry_soil_final ~ 1, data = soil, 
               random = ~ 1|site)

anova(NO3_mod)
plot(NO3_mod)
E <- residuals(NO3_mod)
plot(x = soil$site, y = E)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(NO3_mod, scale = TRUE) 

site_NO3 <- var[1]
tree_NO3 <- var[2]

# save results in dataframe
NO3_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"),  
                          N_NO3 = c(site_NO3, tree_NO3)) %>%
  as_tibble()

rm(NO3_mod, E, var, site_NO3, tree_NO3)

```

## NH4

```{r}

NH4_mod <- lme(mg_N.NH4_kg_dry_soil ~ 1, data = soil, random = ~ 1|site)
anova(NH4_mod)
summary(NH4_mod)

plot(NH4_mod)
E <- residuals(NH4_mod)
plot(x = soil$site, y = E)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(NH4_mod, scale = TRUE) 

site_NH4 <- var[1]
tree_NH4 <- var[2]

# save results in dataframe
NH4_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"),
                          N_NH4 = c(site_NH4, tree_NH4)) %>%
  as_tibble()

rm(NH4_mod, E, var, site_NH4, tree_NH4)

```

## Bulk Density - bulk_den here

```{r}

soil <- soil %>%
  rename(bulk_den = `bulk_den_g_cm-3`)

bulk_mod <- lme(bulk_den ~ 1, data = soil, random = ~1|site)

anova(bulk_mod)
summary(bulk_mod)
plot(bulk_mod)
E <- residuals(bulk_mod)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(bulk_mod, scale = TRUE) 

site_bulk <- var[1]
tree_bulk <- var[2]

# save results in dataframe
bulk_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"),
                          bulk_den = c(site_bulk, tree_bulk)) %>%
  as_tibble()

rm(bulk_mod, E, var, site_bulk, tree_bulk)

```

## Mg

```{r}

Mg_lme <- lme(Mg_cmol_kg ~ 1, data = soil, random = ~ 1|site)

anova(Mg_lme)
summary(Mg_lme)
plot(Mg_lme)
E <- residuals(Mg_lme)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(Mg_lme, scale = TRUE) 

site_Mg <- var[1]
tree_Mg <- var[2]

# save results in dataframe
Mg_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"),
                          Mg = c(site_Mg, tree_Mg)) %>%
  as_tibble()

rm(Mg_mod, E, var, site_Mg, tree_Mg)

```

## Ca

```{r}

Ca_lme <- lme(Ca_cmol_kg ~ 1, data = soil, random = ~ 1|site)
anova(Ca_lme)
summary(Ca_lme)


plot(Ca_lme)
E <- residuals(Ca_lme)
qqnorm(E)
qqline(E)
hist(E)

# extract variance and calculate percentages
# for future reference:
# scale=TRUE calculates % varaince automatically
var <- varcomp(Ca_lme, scale = TRUE) 

site_Ca <- var[1]
tree_Ca <- var[2]

# sum = 1

# save results in dataframe
Ca_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"),
                          Ca = c(site_Ca, tree_Ca)) %>%
  as_tibble()

rm(Ca_lme, E, var, site_Ca, tree_Ca)

```

## K

```{r}

K_lme <- lme(K_cmol_kg ~ 1, data = soil, random = ~ 1|site)

anova(K_lme)
summary(K_lme)
plot(K_lme)
E <- residuals(K_lme)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(K_lme, scale = TRUE) 

site_K <- var[1]
tree_K <- var[2]

# save results in dataframe
K_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"),
                          K = c(site_K, tree_K)) %>%
  as_tibble()

rm(K_mod, E, var, site_K, tree_K)

```

## pH

```{r}

pH_lme <- lme(pH_H2O ~ 1, data = soil, random = ~ 1|site)

anova(pH_lme)
summary(pH_lme)
plot(pH_lme)
E <- residuals(pH_lme)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(pH_lme, scale = TRUE) 

site_pH <- var[1]
tree_pH <- var[2]

# save results in dataframe
pH_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"),
                          pH = c(site_pH, tree_pH)) %>%
  as_tibble()

rm(pH_lme, E, var, site_pH, tree_pH)

```


## GWC

```{r}

soil <- soil %>%
  rename(GWC = `gwc_g_g-1_dry_soil`)

GWC_mod <- lme(GWC ~ 1, data = soil, random = ~ 1|site)

anova(GWC_mod) 
summary(GWC_mod)
plot(GWC_mod)
E <- residuals(GWC_mod)
plot(x = soil$site, y = E)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(GWC_mod, scale = TRUE) 

site_GWC <- var[1]
tree_GWC <- var[2]

# save results in dataframe
GWC_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"),
                          GWC = c(site_GWC, tree_GWC)) %>%
  as_tibble()

rm(GWC_mod, E, var, site_GWC, tree_GWC)

```


## N% soil

```{r}

soil <- soil %>%
  rename(N = `N_%`)

N_mod <- lme(N ~ 1, data = soil, random = ~ 1|site)

anova(N_mod) 
summary(N_mod)
plot(N_mod)
E <- residuals(N_mod)
plot(x = soil$site, y = E)
qqnorm(E)
qqline(E)
hist(E)

var <- varcomp(N_mod, scale = TRUE) 

site_N <- var[1]
tree_N <- var[2]

# save results in dataframe
N_variance <- data.frame(Ecological_Scale = c("Site", "Tree + Error"),
                          N = c(site_N, tree_N)) %>%
  as_tibble()

rm(N_mod, E, var, site_N, tree_N)

```


### combine soil variance partitioning

```{r}

soil_variance <- left_join(P_variance, NO3_variance, by = "Ecological_Scale")
soil_variance <- left_join(soil_variance, NH4_variance, by = "Ecological_Scale")
soil_variance <- left_join(soil_variance, Mg_variance, by = "Ecological_Scale")
soil_variance <- left_join(soil_variance, Ca_variance, by = "Ecological_Scale")
soil_variance <- left_join(soil_variance, K_variance, by = "Ecological_Scale")
soil_variance <- left_join(soil_variance, bulk_variance, by = "Ecological_Scale")
soil_variance <- left_join(soil_variance, N_variance, by = "Ecological_Scale")
soil_variance <- left_join(soil_variance, pH_variance, by = "Ecological_Scale")
soil_variance <- left_join(soil_variance, GWC_variance, by = "Ecological_Scale")

soil_variance <- soil_variance %>%
  mutate(Olsen_P = round(Olsen_P, digits = 2),
         N_NO3 = round(N_NO3, digits = 2),
         N_NH4 = round(N_NH4, digits = 2),
         Mg = round(Mg, digits = 2),
         Ca = round(Ca, digits = 2),
         bulk_den = round(bulk_den, digits = 2),
         pH = round(pH, digits = 2),
         GWC = round(GWC, digits = 2),
         N = round(N, digits =2)) %>%
  rename(PO4 = Olsen_P, NO3 = N_NO3, NH4 = N_NH4,
         Bulk = bulk_den, GWC = GWC, `N%` = N )

soil_var_long <- pivot_longer(soil_variance, cols = 2:11, names_to = "Variable", values_to = "Variance") %>%
  arrange(Variable) %>%
  mutate(Ecological_Scale = factor(Ecological_Scale, levels = c("Site", "Tree + Error")),
         Variable = factor(Variable, levels = c("NO3", "NH4", "PO4", "Mg", "Ca", "GWC", "K", "Bulk","N%", "pH"))) %>%
  mutate(Variance = round(Variance, digits =2))

(soil.variance <- ggplot(data = soil_var_long, 
                         aes(x = Variable, y = Variance, 
                             fill = Ecological_Scale)) +
  geom_col(position = "fill")  +
  scale_fill_manual(values = pal.var.3)+
    theme_minimal() +
    ylab("Variance") +
    theme(axis.text.x = element_text(size = 16, angle = 45, hjust = 1, vjust = 1),
          axis.title.x = element_blank(), 
          axis.text.y = element_text(size = 14),
          axis.title.y = element_text(size = 14),
          legend.position = "none") +
    coord_cartesian(xlim = c(1,10)) +
    guides(fill = guide_legend(title = "Ecological Scale")) +
  geom_hline(yintercept = 0.5, color = "white", linetype = 5) )

# combine and export root and soil var plots

ggarrange(soil.variance, root.var.plot,
          ncol = 2, nrow = 1,
          widths = c(1.5, 1))

# ggsave("output/merged_variable_variance_barchart_2024-09-12.png",
#        height = 4, width = 7, unit = "in", dpi = 800)

```

# Bivariate Relationships

DAVE SUGGESTED: NEED TO CENTER AND STANDARDIZE (treat like pca data)

## Root traits ~ all soil and DBH

```{r}

## dataset prep

all.30 <- all %>%
  mutate(Mg_log = log(Mg_cmol_kg),
         Ca_log = log(Ca_cmol_kg),
         P_log = log(P_mg_kg),
         pH_log = log(pH_H2O),
         NH4_log = log(mg_N.NH4_kg_dry_soil),
         GWC_log = log(`gwc_g_g-1_dry_soil`),
         PME_log = log(umol_pNP_g_h),
         RESP_log = log(resp_ug_g_min),
         SRL_log = log(SRL_m_g))

# to try ##############

# all.30 <- decostand()

################################## MYC ######################################


m0.myc <- lm(myc_percent ~ `N_%` + K_cmol_kg + Mg_log + Ca_log + P_log +
            `bulk_den_g_cm-3` + pH_log + GWC_log + NH4_log + DBH_cm, data = all.30)
anova(m0.myc) # extract sign. x var for new model
m0.myc <- lm(myc_percent ~ Mg_log + P_log + NH4_log, data = all.30)
anova(m0.myc) # extract sign. x var for new model
m0.myc <- lm(myc_percent ~ Mg_log, data = all.30)
anova(m0.myc)

# compare linear model to LME model
m1.myc <- lmer(myc_percent ~ Mg_log + (1|site), 
          REML = F, data = all.30)

AIC.table <- MuMIn::model.sel(m0.myc, m1.myc)
(AIC.table[ , c("df", "logLik", "AICc", "delta")])

E <- resid(m0.myc)
plot(x = all$site, y = E)
plot(m0.myc)

summary(m0.myc)

################################ PME #########################################

# PME responds to Mg and bulk density - try with varIdent for each site
# model not fit well yet

m0.pme <- lm(PME_log ~ `N_%` + K_cmol_kg + Mg_log + Ca_log + P_log +
            `bulk_den_g_cm-3` + pH_log + GWC_log + NH4_log + DBH_cm, data = all.30)
anova(m0.pme)
m0.pme <- lm(PME_log ~ Mg_log + `bulk_den_g_cm-3`, data = all.30)
anova (m0.pme)
m0.pme <- lm(PME_log ~ `bulk_den_g_cm-3`, data = all.30)
anova (m0.pme)

E <- resid(m0.pme)
hist(E)
plot(x = all$site, y = E)

m1.pme <- lmer(PME_log ~ Mg_log + `bulk_den_g_cm-3` + (1|site), 
           REML = F, data = all.30)

AIC.table <- MuMIn::model.sel(m0.pme, m1.pme)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

summary(m0.pme)

# rm(m0.pme, m1.pme)

################################## RESP ######################################

m0 <- lm(RESP_log ~ `N_%` + K_cmol_kg + Mg_log + Ca_log + P_log +
            `bulk_den_g_cm-3` + pH_log + GWC_log + NH4_log + DBH_cm, data = all.30)
anova(m0)

m0 <- lm(RESP_log ~ pH_log + `bulk_den_g_cm-3`, data = all.30)
anova(m0)

plot(m0)

rm(m0)

##################################### SRL ####################################

# also need varIdent

m0 <- lm(SRL_log ~ `N_%` + K_cmol_kg + Mg_log + Ca_log + P_log +
            `bulk_den_g_cm-3` + pH_log + GWC_log + NH4_log + DBH_cm, data = all.30)
anova(m0)

m0 <- lm(SRL_log ~ pH_log + `bulk_den_g_cm-3`, data = all.30)
anova(m0)

m0 <- lm(SRL_log ~ NH4_log, data = all.30)
anova(m0)

E<- resid(m0)
plot(x= all$site, y = E)

rm(m0)

############################ Diameter #####################

m0 <- lm(D_mm ~ `N_%` + K_cmol_kg + Mg_log + Ca_log + P_log +
            `bulk_den_g_cm-3` + pH_log + GWC_log + NH4_log + DBH_cm, data = all.30)
anova(m0)

m0 <- lm(D_mm ~ `bulk_den_g_cm-3`, data = all.30)
anova(m0)

plot(m0)

#rm(m0)

############################ RTD ################################

m0.rtd <- lm(RTD_g_cm3 ~ `N_%` + K_cmol_kg + Mg_log + Ca_log + P_log +
            `bulk_den_g_cm-3` + pH_log + GWC_log + NH4_log + DBH_cm, data = all.30)
anova(m0.rtd)

m0.rtd <- lm(RTD_g_cm3 ~  Ca_log, data = all.30)
anova(m0.rtd)

summary(m0.rtd)

plot(m0.rtd)

m1.rtd <- lmer(RTD_g_cm3 ~  Ca_log + (1|site), 
           REML = F, data = all.30)

AIC.table <- MuMIn::model.sel(m0.rtd, m1.rtd)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

############################## N% #################################

m0.n <- lm(N_percent ~ `N_%` + K_cmol_kg + Mg_log + Ca_log + P_log +
            `bulk_den_g_cm-3` + pH_log + GWC_log + NH4_log + DBH_cm, data = all.30)
anova(m0.n)

m0.n <- lm(N_percent ~ Mg_log + Ca_log + pH_log + GWC_log, data = all.30)
anova(m0.n)

m0.n <- lm(N_percent ~ pH_log, data = all.30)
anova(m0.n)

plot(m0.n)

summary(m0.n)

m1.n <- lmer(N_percent ~ pH_log + (1|site), 
           REML = F, data = all.30)

AIC.table <- MuMIn::model.sel(m0.n, m1.n)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

############################## RBI ################################

m0 <- lm(RBI_t_cm ~ `N_%` + K_cmol_kg + Mg_log + Ca_log + P_log +
            `bulk_den_g_cm-3` + pH_log + GWC_log + NH4_log + DBH_cm, data = all.30)
anova(m0)

m0 <- lm(RBI_t_cm ~ NH4_log, data = all.30)
anova(m0)

```

### Plotting significant linear model relationships from above

#### Myc ~ Mg


```{r}

# extract model to plot with data

aug.m0.myc <- broom::augment(m0.myc, se_fit = TRUE)

eq <- substitute((bold(a))~italic(R)^2~"="~R2~", p < 0.001", 
         list(R2 = format(summary(m0.myc)$r.squared, digits = 2)))
eq <- as.character(as.expression(eq))

myc.Mg.plot <- ggplot(data = all.30, aes(x=Mg_log, y = myc_percent)) +
  geom_point(aes(color = site, shape = site),
            size = 4) +
  scale_color_manual(values = pal3) +
  geom_line(aes(y = aug.m0.myc$.fitted)) +
  geom_ribbon(mapping = aes(ymin = .fitted - 1.96 * .se.fit, 
                                ymax = .fitted + 1.96 * .se.fit), 
              data = aug.m0.myc,
                  colour = "gray",
              alpha = 0.1) + 
  geom_text(label = eq, parse = TRUE, size = 5,
            x = 1.5, y = 115) +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.position = "none") +
  xlab(expression(Log[e]~Soil~Mg~(cmol~kg^{-1}))) +
  ylab("AM (%)") 

myc.Mg.plot

# png("output/myc.Mg.plot-2024-1-25.png", width = 12, height = 8, unit = "in", res = 800)
# myc.Mg.plot
# dev.off()
 

```

#### PME ~ bulk den


```{r}

aug.m0.pme <- broom::augment(m0.pme, se_fit = TRUE)

eq <- substitute((bold(b))~italic(R)^2~"="~R2~", p < 0.001", 
         list(R2 = format(summary(m0.pme)$r.squared, digits = 2)))
eq <- as.character(as.expression(eq))

pme.bulk.plot <- ggplot(data = all.30, aes(y=PME_log, x = `bulk_den_g_cm-3`)) +
  geom_point(aes(color = site, shape = site),
            size = 4) +
  scale_color_manual(values = pal3) +
  geom_line(aes(y = aug.m0.pme$.fitted)) +
  geom_ribbon(mapping = aes(ymin = .fitted - 1.96 * .se.fit, 
                                ymax = .fitted + 1.96 * .se.fit), 
              data = aug.m0.pme,
                  colour = "gray",
              alpha = 0.1) + 
  geom_text(label = eq, parse = TRUE, size = 5,
            x = 0.8, y = 5.0) +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.position = "none") +
  ylab(expression(Log[e]~PME~(mu*mol~pNP~g^{-1}~h^{-1}))) +
  xlab(expression(Soil~Bulk~Density~(g~cm^{-3}))) 

pme.bulk.plot

# png("output/pme.bulk.plot-2024-05-02.png", width = 12, height = 8, unit = "in", res = 800)
# pme.bulk.plot
# dev.off()

############
```

#### N ~ pH

```{r}

# extract model to plot with data

aug.m0.n <- broom::augment(m0.n, se_fit = TRUE)

eq <- substitute((bold(c))~italic(R)^2~"="~R2~", p < 0.001", 
         list(R2 = format(summary(m0.n)$r.squared, digits = 2)))
eq <- as.character(as.expression(eq))

n.pH.plot <- ggplot(data = all.30, aes(y=N_percent, x = pH_log)) +
  geom_point(aes(color = site, shape = site),
            size = 4) +
  scale_color_manual(values = pal3) +
  geom_line(aes(y = aug.m0.n$.fitted)) +
  geom_ribbon(mapping = aes(ymin = .fitted - 1.96 * .se.fit, 
                                ymax = .fitted + 1.96 * .se.fit), 
              data = aug.m0.n,
                  colour = "gray",
              alpha = 0.1) + 
  geom_text(label = eq, parse = TRUE, size = 5,
            x = 1.835, y = 3) +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.position = "none") +
  xlab(expression(Log[e]~Soil~pH)) +
  ylab("N (%)") 

n.pH.plot

# png("output/n.pH.plot-2024-1-25.png", width = 12, height = 8, unit = "in", res = 800)
# n.pH.plot
# dev.off()

```

#### RTD ~ Ca

```{r}

aug.m0.rtd <- broom::augment(m0.rtd, se_fit = TRUE)

eq <- substitute((bold(d))~italic(R)^2~"="~R2~", p < 0.05", 
         list(R2 = format(summary(m0.rtd)$r.squared, digits = 2)))
eq <- as.character(as.expression(eq))

rtd.ca.plot <- ggplot(data = all.30, aes(y=RTD_g_cm3, x = Ca_log)) +
  geom_point(aes(color = site, shape = site),
            size = 4) +
  scale_color_manual(values = pal3) +
  geom_line(aes(y = aug.m0.rtd$.fitted)) +
  geom_ribbon(mapping = aes(ymin = .fitted - 1.96 * .se.fit, 
                                ymax = .fitted + 1.96 * .se.fit), 
              data = aug.m0.rtd,
                  colour = "gray",
              alpha = 0.1) + 
  geom_text(label = eq, parse = TRUE, size = 5,
            x = 2.45, y = 0.255) +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.position = "none") +
  xlab(expression(Log[e]~Soil~Ca~(cmol~kg^{-1}))) +
  ylab(expression(RTD~(g~cm^{-3}))) 

rtd.ca.plot

# png("output/rtd.ca.plot-2024-05-02.png", width = 12, height = 8, unit = "in", res = 800)
# rtd.ca.plot
# dev.off()

```


##### Panel plot

```{r}

panel_root_soil <- ggarrange(myc.Mg.plot, pme.bulk.plot, 
                             n.pH.plot, rtd.ca.plot,
                    ncol = 2, nrow = 2)

png("output/panel_root_soil-2024-09-13.png", width = 12, height = 8, unit = "in", res = 800)
panel_root_soil
dev.off()

```


## Root traits ~ all root traits and DBH

```{r}

## dataset prep

root.90 <- root %>%
  mutate(SRL_log = log(SRL_m_g),
         RESP_log = log(resp_ug_g_min),
         PME_log = log(umol_pNP_g_h)) %>%
  left_join(., dbh, by = c("site", "tree"))

############################## MYC ##########################################

M0.myc <- lm(myc_percent ~ SRL_log + RESP_log + PME_log + D_mm + RTD_g_cm3 +
           N_percent + RBI_t_cm + DBH_cm, data = root.90)
anova(M0.myc)

M0.myc <- lm(myc_percent ~ N_percent, data = root.90)
anova(M0.myc)

summary(M0.myc)

plot(M0.myc)

M1.myc <- lmer(myc_percent ~ N_percent + (1|site), 
           REML = F, data = root.90)

M2.myc <- lmer(myc_percent ~ N_percent + (1|site/tree), 
           REML = F, data = root.90)

AIC.table <- MuMIn::model.sel(M0.myc, M1.myc, M2.myc)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

summary(M2.myc)

M2.myc <- lmer(myc_percent ~ N_percent + (1|site/tree), 
           REML = T, data = root.90)

summary(M2.myc)

estimate <- 6.680      
lower.ci <- estimate - 1.96*5.013   
upper.ci <- estimate + 1.96*5.013   

(lower.ci)
(upper.ci)

# not signif.

######################## PME ##################################################

M0.pme <- lm(PME_log ~ myc_percent + SRL_log + RESP_log + D_mm + RTD_g_cm3 +
           N_percent + RBI_t_cm + DBH_cm, data = root.90)
anova(M0.pme)

M0.pme <- lm(PME_log ~ myc_percent, data = root.90)
anova(M0.pme)

summary(M0.pme)

M1.pme <- lmer(myc_percent ~ PME_log + (1|site), 
           REML = F, data = root.90)

M2.pme <- lmer(myc_percent ~ PME_log + (1|site/tree), 
           REML = F, data = root.90)

AIC.table <- MuMIn::model.sel(M0.myc, M1.myc, M2.pme)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

summary(M2.pme)

# not signif.

################################## RESP ##################################

M0.resp <- lm(RESP_log ~ myc_percent + SRL_log + N_percent  + D_mm + RTD_g_cm3 +
           PME_log  + RBI_t_cm + DBH_cm, data = root.90)
anova(M0.resp)

M0.resp <- lm(RESP_log ~ SRL_log, data = root.90)
anova(M0.resp)

summary(M0.resp)

M1.resp <- lmer(RESP_log ~ SRL_log + (1|site), 
           REML = F, data = root.90)

M2.resp <- lmer(RESP_log ~ SRL_log + (1|site/tree), 
           REML = F, data = root.90)

AIC.table <- MuMIn::model.sel(M0.resp, M1.resp, M2.resp)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

M2.resp <- lmer(RESP_log ~ SRL_log + (1|site/tree), 
           REML = T, data = root.90)

summary(M2.resp)

estimate <- 0.89017
se <- 0.08813
(lower.ci <- estimate - 1.96*se)
(upper.ci <- estimate + 1.96*se)

# M2 signif.

################################## SRL ##################################

M0.srl <- lm(SRL_log ~ myc_percent + RESP_log + N_percent  + D_mm + RTD_g_cm3 +
           PME_log  + RBI_t_cm + DBH_cm, data = root.90)
anova(M0.srl)

M0.srl <- lm(SRL_log ~ myc_percent + RESP_log + D_mm  + RTD_g_cm3 +
           RBI_t_cm, data = root.90)
anova(M0.srl)

  ## many interactions seem significant
  ## leaving out interaction from M0

summary(M0.srl)

M1.srl <- lmer(SRL_log ~ myc_percent + RESP_log  + D_mm + RTD_g_cm3 +
           RBI_t_cm + (1|site), 
           REML = F, data = root.90)

M2.srl <- lmer(SRL_log ~ myc_percent + RESP_log  + D_mm + RTD_g_cm3 +
           RBI_t_cm + (1|site/tree), 
           REML = F, data = root.90)

AIC.table <- MuMIn::model.sel(M0.srl, M1.srl, M2.srl)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

# M0 signif.

################################## D ##################################

M0.d <- lm(D_mm ~ myc_percent + RESP_log + N_percent + SRL_log + RTD_g_cm3 +
           PME_log  + RBI_t_cm + DBH_cm, data = root.90)
anova(M0.d)

M0.d <- lm(D_mm ~ SRL_log + RTD_g_cm3 + RBI_t_cm, data = root.90)
anova(M0.d)

M1.d <- lmer(D_mm ~ SRL_log + RTD_g_cm3 + RBI_t_cm + (1|site), 
           REML = F, data = root.90)

M2.d <- lmer(D_mm ~ SRL_log + RTD_g_cm3 + RBI_t_cm + (1|site/tree), 
           REML = F, data = root.90)

AIC.table <- MuMIn::model.sel(M0.d, M1.d, M2.d)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

summary(M0.d)

plot(M0.d)

# M0 sign.
# try with GAMM?

################################## RTD ##################################

M0.rtd <- lm(RTD_g_cm3 ~ myc_percent + RESP_log + N_percent + SRL_log + D_mm +
           PME_log  + RBI_t_cm + DBH_cm, data = root.90)
anova(M0.rtd)

M0.rtd <- lm(RTD_g_cm3 ~ SRL_log*D_mm, data = root.90)

M1.rtd <- lmer(RTD_g_cm3 ~ SRL_log*D_mm + (1|site), 
           REML = F, data = root.90)

M2.rtd <- lmer(RTD_g_cm3 ~ SRL_log*D_mm + (1|site/tree), 
           REML = F, data = root.90)

AIC.table <- MuMIn::model.sel(M0.rtd, M1.rtd, M2.rtd)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

anova(M0.rtd)

summary(M0.rtd)

plot(M0.rtd)

# M0 signif.

################################## N ##################################

M0.n <- lm(N_percent ~ myc_percent + SRL_log + RESP_log  + D_mm + RTD_g_cm3 +
           PME_log  + RBI_t_cm + DBH_cm, data = root.90)
anova(M0.n)

M0.n <- lm(N_percent ~ myc_percent, data = root.90)
anova(M0.n)

summary(M0.n)

M1.n <- lmer(N_percent ~ myc_percent + (1|site), 
           REML = F, data = root.90)

M2.n <- lmer(N_percent ~ myc_percent + (1|site/tree), 
           REML = F, data = root.90)

AIC.table <- MuMIn::model.sel(M0.n, M1.n, M2.n)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

M2.n <- lmer(N_percent ~ myc_percent + (1|site/tree), 
           REML = T, data = root.90)

summary(M2.n)

estimate <- 0.003926   
se <- 0.002103      
(lower.ci <- estimate - 1.96*se)
(upper.ci <- estimate + 1.96*se)

# not signif.

################################## RBI ##################################

M0.rbi <- lm(RBI_t_cm ~ N_percent + myc_percent + SRL_log + N_percent  + D_mm + RTD_g_cm3 +
           PME_log + DBH_cm, data = root.90)
anova(M0.rbi)

M0.rbi <- lm(RBI_t_cm ~ D_mm, data = root.90)
anova(M0.rbi)

M1.rbi <- lmer(RBI_t_cm ~ D_mm + (1|site), 
           REML = F, data = root.90)

M2.rbi <- lmer(RBI_t_cm ~ D_mm + (1|site/tree), 
           REML = F, data = root.90)

AIC.table <- MuMIn::model.sel(M0.rbi, M1.rbi, M2.rbi)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

summary(M0.rbi)

plot(M0.rbi)

# M0 signif.

```
### DBH summary

```{r}

tree <- root.90 %>%
  group_by(site) %>%
   summarize(DBH_mean = mean(DBH_cm), 
             DBH_sd = sd(DBH_cm))

```
```



### Plotting significant relationships from above

#### RESP ~ SRL

```{r}

# M2.resp <- lmer(RESP_log ~ SRL_log + (1|site/tree), 
#            REML = T, data = root.90)

ggplot(aes(x = SRL_log, y = RESP_log, color = site), data = root.90) +
  geom_point()

```

#### SRL ~ traits

```{r}

# M0.srl <- lm(SRL_log ~ myc_percent + RESP_log  + D_mm + RTD_g_cm3 +
#            RBI_t_cm, data = root.90)

ggplot(aes(y=SRL_log, x = RESP_log, color = tree), data = root.90) +
  geom_point() +
  facet_wrap(~site)

```

#### D ~ traits

```{r}
# M0.d <- lm(D_mm ~ SRL_log + RTD_g_cm3 + RBI_t_cm, data = root.90)

ggplot(aes(y=D_mm, x = SRL_log, size = RTD_g_cm3, color = RBI_t_cm), data = root.90) +
  geom_point()
```


#### RTD ~ traits

```{r}
# M0.rtd <- lm(RTD_g_cm3 ~ SRL_log*D_mm, data = root.90)

ggplot(aes(x=D_mm, size = SRL_log, y = RTD_g_cm3), data = root.90) +
  geom_point()

```

#### RBI ~ traits

```{r}
M0.rbi <- lm(RBI_t_cm ~ D_mm, data = root.90)

ggplot(aes(x=D_mm, y = RBI_t_cm), data = root.90) +
  geom_point()
```


# Raw Data variation graph

```{r}

## RBI - all variance came from within trees 

ggplot(aes(x= tree, y = RBI_t_cm), data = root) +
  geom_boxplot() +
  facet_wrap(~site) +
  theme()

ggplot(aes(x= site, y = RBI_t_cm), data = root) +
  geom_boxplot() +
  geom_jitter(aes(color = tree, shape = tree)) +
  theme()

## PME - most variable trait, variance came from across sites mostly

### boxplot with overlaid points

raw.pme.plot <- 
  ggplot(data = root, aes(x=site, y = umol_pNP_g_h)) +
  geom_boxplot() +
  geom_point(aes(color = site), 
             shape = 16,
             size = 4,
             alpha = 0.5,
             position = "jitter") +
  scale_color_manual(values = pal3) +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 15),
        axis.title = element_text(size = 17),
        legend.position = "none") +
  xlab(NULL) + 
  ylab(expression(Phosphatase~Activity~(mu*mol~pNP~g^{-1}~h^{-1}))) +
  scale_x_discrete(labels=c('Horizontes', 'Santa Rosa', 'Palo Verde'))

raw.pme.plot

png("output/raw.pme.plot-2024-1-17.png", width = 12, height = 8, unit = "in", res = 800)
raw.pme.plot
dev.off()

## Olsen P 

raw.p.plot <- 
  ggplot(data = soil, aes(x=site, y = P_mg_kg)) +
  geom_boxplot() +
  geom_point(aes(color = site), 
             shape = 16,
             size = 4,
             alpha = 0.5,
             position = "jitter") +
  scale_color_manual(values = pal3) +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 15),
        axis.title = element_text(size = 17),
        legend.position = "none") +
  xlab(NULL) + 
  ylab(expression(Olsen~P~(mg~kg^{-1}))) +
  scale_x_discrete(labels=c('Horizontes', 'Santa Rosa', 'Palo Verde'))

raw.p.plot

png("output/raw.p.plot-2024-1-17.png", width = 12, height = 8, unit = "in", res = 800)
raw.p.plot
dev.off()

## NO3-N 

raw.no3.plot <- 
  ggplot(data = soil, aes(x=site, y = mg_N.NO3_kg_dry_soil_final)) +
  geom_boxplot() +
  geom_point(aes(color = site), 
             shape = 16,
             size = 4,
             alpha = 0.5,
             position = "jitter") +
  scale_color_manual(values = pal3) +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 15),
        axis.title = element_text(size = 17),
        legend.position = "none") +
  xlab(NULL) + 
  ylab(expression(Nitrate-N~(mg~kg^{-1}))) +
  scale_x_discrete(labels=c('Horizontes', 'Santa Rosa', 'Palo Verde')) 

raw.no3.plot


## NH4-N 

raw.nh4.plot <- 
  ggplot(data = soil, aes(x=site, y = mg_N.NH4_kg_dry_soil)) +
  geom_boxplot() +
  geom_point(aes(color = site), 
             shape = 16,
             size = 4,
             alpha = 0.5,
             position = "jitter") +
  scale_color_manual(values = pal3) +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 15),
        axis.title = element_text(size = 17),
        legend.position = "none") +
  xlab(NULL) + 
  ylab(expression(Ammonium-N~(mg~kg^{-1}))) +
  scale_x_discrete(labels=c('Horizontes', 'Santa Rosa', 'Palo Verde')) +
  ylim(0, 16)

raw.nh4.plot


## Mg

raw.mg.plot <- 
  ggplot(data = soil, aes(x=site, y = Mg_cmol_kg)) +
  geom_boxplot() +
  geom_point(aes(color = site), 
             shape = 16,
             size = 4,
             alpha = 0.5,
             position = "jitter") +
  scale_color_manual(values = pal3) +
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 15),
        axis.title = element_text(size = 17),
        legend.position = "none") +
  xlab(NULL) + 
  ylab(expression(Magnesium~(cmol~kg^{-1}))) +
  scale_x_discrete(labels=c('Horizontes', 'Santa Rosa', 'Palo Verde')) +
  ylim(0, 16)

raw.mg.plot
           
```




# Basic graphs of site variables

### Soil - Perform EDA and produce graphs of soil variables

```{r}

## EDA of soil texture fractions
## make into stacked bar chart like P fractions

sand <- ggplot(soil, aes(x = site, y = `sand_m`, color = site)) +
  geom_point(shape = 1, size = 2) +
  labs(x = "", y = "Sand (%)") +
  scale_y_continuous(limits = c(10, 60)) +
  theme(legend.position = "none") +
  scale_color_brewer(palette = "Dark2")

silt <- ggplot(soil, aes(x = site, y = `silt_m`, color = site)) +
  geom_point(shape = 1, size = 2, ) +
  labs(x = "", y = "Silt (%)") +
  scale_y_continuous(limits = c(10, 60)) +
  theme(legend.position = "none") +
  scale_color_brewer(palette = "Dark2")

clay <- ggplot(soil, aes(x = site, y = `clay_m`, color = site)) +
  geom_point(shape = 1, size = 2) +
  labs(x = "", y = "Clay (%)") +
  scale_y_continuous(limits = c(10, 60)) +
  theme(legend.position = "none") +
  scale_color_brewer(palette = "Dark2")

gridExtra::grid.arrange(sand, silt, clay, 
                        nrow = 1, bottom = "Site")

```
**Fig. 1.** Sand, silt, and clay fractions for the 3 sampling sites (n = 5), where S is Santa Rosa, H is Horizontes, and P is Palo Verde. 

Data may cause heteroscedastic residuals in models.


## Soil Phosphorus Fractions - stacked bar chart
 

```{r}

## P fraction EDA

# select P fraction site averages and pivot longer to plot in stacked bar chart

Pfrac_long <- soil %>%
  filter(tree == "1") %>%
  dplyr::select(site, 
                Pi_NaHCO3_m,
            Po_NaHCO3_m,
            Pi_NaOH_m,
            Po_NaOH_m,
            Pi_HCl_m,
            P_residual_m) %>%
  pivot_longer(cols = c(Pi_NaHCO3_m, Po_NaHCO3_m, 
         Pi_NaOH_m, Po_NaOH_m, Pi_HCl_m, P_residual_m),
         names_to = "P_fraction",
         values_to = "mean_mg_kg") %>%
  # mutate(site = as.factor(site)) %>%
  mutate(P_fraction = str_replace(P_fraction, pattern = "_m", replacement = ""))

# reorder factor level
Pfrac_long$P_fraction <- factor(Pfrac_long$P_fraction,
                                     levels = c("P_residual", 
                                                "Pi_HCl",
                                                "Po_NaOH",
                                                "Pi_NaOH", 
                                                "Po_NaHCO3",
                                                "Pi_NaHCO3")) 

## plot stacked barchart
## add error bars?

Pfrac <- ggplot(Pfrac_long, 
       aes(x = site, y = mean_mg_kg, fill = P_fraction)) +
  geom_bar(position = "stack", stat = "identity",
           color = "white") +
  scale_fill_manual(values = cascades) +
  scale_x_discrete(labels = c("Horizontes", "Santa Rosa", "Palo Verde")) +
  labs(x = NULL, y = expression(Quantity~(mg~kg^{-1})),
       fill = "P Fraction") +
    theme(axis.text = element_text(size = 20),
          axis.title = element_text(size = 20)) 
  
Pfrac

# export to output folder

# png('output/P_fractions_barchart_2024-1-18.png', height = 8, width = 12, unit = "in", res = 800)
# Pfrac
# dev.off()

rm(Pfrac_long, Pfrac)

```
**Fig. 2.** Averaged soil phosphorus fractions within study sites (n = 5), where S is Santa Rosa, H is Horizontes, and P is Palo Verde. Pi is inorganic P, Po is organic P, NaHCO3 is bicarbonate, NaOH is sodium hydroxide, HCl is hydrochloric acid. 

Santa Rosa and Palo Verde had similar P fractions and sums, but Horizontes had about double the amount of summed P, with notably higher quantitites of Po-NaOH, Pi-NaOH, and Po-NaHCO3.
 




## Total soil C and N and available P

```{r}

C <- ggplot(data = soil, aes(x = site, y = `C_%`, color = site)) +
  geom_boxplot() +
  geom_point(shape = 1, size = 2, 
                ## change point format to distinguish between
                ## boxplot outliers and gepm points
             position = position_jitter(w = 0.2, h = 0)) +
                ## jitter points ONLY with respect to the x-axis
  scale_color_brewer(palette = "Dark2") +
  labs(x = "", y = "Total C (%)") +
  scale_y_continuous(limits = c(0, 6.25)) +
  theme(legend.position = "none")

N <- ggplot(data = soil, aes(x = site, y = `N_%`, color = site)) +
  geom_boxplot() +
  geom_point(shape = 1, size = 2, 
               ## change point format to distinguish between
               ## boxplot outliers and gepm points
             position = position_jitter(w = 0.2, h = 0)) +
               ## jitter points ONLY with respect to the x-axis
  scale_color_brewer(palette = "Dark2") +
  labs(x = "", y = "Total N (%)") +
  scale_y_continuous(limits = c(0, 1.5)) +
  theme(legend.position = "none")

P.Olsen <- ggplot(data = soil, aes(x = site, y = `P_mg_kg`, color = site)) +
  geom_boxplot() +
  geom_point(shape = 1, size = 2, 
               ## change point format to distinguish between
               ## boxplot outliers and gepm points
             position = position_jitter(w = 0.2, h = 0)) +
               ## jitter points ONLY with respect to the x-axis
  scale_color_brewer(palette = "Dark2") +
  labs(x = "", y = "Olsen P (mg/kg)") +
  scale_y_continuous(limits = c(0, 6.25)) +
  theme(legend.position = "none")

gridExtra::grid.arrange(C, N, P.Olsen, 
                        nrow = 1, bottom = "Site")

```
**Fig. 3.** Soil total C (%), total N (%), and available P (Olsen P modified at pH 8.5; mg/kg) across sites (n = 10). Note the units and scales differ.


## Soil pH and bulk density

```{r}

pH <- ggplot(data = soil, aes(x = site, y = pH_H2O, color = site)) +
  geom_boxplot() +
  geom_point(shape = 1, size = 2,
             position = position_jitter(w = 0.25, h = 0)) +
  scale_color_brewer(palette = "Dark2") +
  scale_y_continuous(limits = c(5, 8)) +
  labs(x = "", y = "pH in H2O") +
  theme(legend.position = "none")

bulk <- ggplot(data = soil, aes(x = site, y = bulk_den, color = site)) +
  geom_boxplot() +
  geom_point(shape = 1, size = 2,
             position = position_jitter(w = 0.25, h = 0)) +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "", y = "Bulk Density (g/cm-3)") +
  theme(legend.position = "none")

gridExtra::grid.arrange(pH, bulk,
                        nrow = 1, bottom = "Site")

```
**Fig. 4** Soil pH and bulk density (n = 10) across sites. Note that y-axis scales and units differ.


## Cations

```{r}

## cations

CEC <- ggplot(data = soil, aes(x = site, y = `CEC_cmol_kg`, color = site)) +
  geom_boxplot() +
  geom_point(shape = 1, size = 2, 
             position = position_jitter(w = 0.2, h = 0)) +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "", y = "CEC (cmol/kg)") +
 # scale_y_continuous(limits = c(0, 6.25)) +
  theme(legend.position = "none")

Ca <- ggplot(data = soil, aes(x = site, y = `Ca_cmol_kg`, color = site)) +
  geom_boxplot() +
  geom_point(shape = 1, size = 2, 
             position = position_jitter(w = 0.2, h = 0)) +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "", y = "Ca2+ (cmol/kg)") +
 # scale_y_continuous(limits = c(0, 6.25)) +
  theme(legend.position = "none")

Mg <- ggplot(data = soil, aes(x = site, y = `Mg_cmol_kg`, color = site)) +
  geom_boxplot() +
  geom_point(shape = 1, size = 2, 
             position = position_jitter(w = 0.2, h = 0)) +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "", y = "Mg2+ (cmol/kg)") +
 # scale_y_continuous(limits = c(0, 6.25)) +
  theme(legend.position = "none")

K <- ggplot(data = soil, aes(x = site, y = `K_cmol_kg`, color = site)) +
  geom_boxplot() +
  geom_point(shape = 1, size = 2, 
             position = position_jitter(w = 0.2, h = 0)) +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "", y = "K+ (cmol/kg)") +
 # scale_y_continuous(limits = c(0, 6.25)) +
  theme(legend.position = "none")

gridExtra::grid.arrange(CEC, Ca, Mg, K, 
                        nrow = 1, bottom = "Site")

```
**Fig. 5** Cation exchange capacity and concentrations of individual cations across sites (n = 10). Note y-axis scales differ.


# P fraction EDA with roots and orthophosphate

This should be ignored mostly! The soil organic P fractions are shared between two trees in every site. Need good moedls to consider this, and even then it's not strong evidence. 

Schaap 2021 found negative relationships between seasonal changes in bicarbonate and NaOH organic P fractions in the central Amazon. 

```{r}
# get tree-level P fraction and texture data to check for correlations

tree1s <- pfrac %>%
  dplyr::select(-c(tree2)) %>%
  rename(tree = tree1)

tree2s <- pfrac %>%
  dplyr::select(-c(tree1)) %>%
  rename(tree = tree2)

pfrac_longer <- rbind(tree1s, tree2s) %>% # arrange() ?
    mutate(site = as.factor(site),
                     tree = as.factor(tree))

all.pt <- left_join(all, pfrac_longer, by = c("site", "tree"))

# fractions ~ root PME
              
ggplot(data = all.pt, aes(x = log(Pi_NaHCO3_mg_kg), y = log(umol_pNP_g_h))) +
  geom_point(aes(color = site)) +
  stat_smooth(method = "lm",
              formula = y ~ x)

ggplot(data = all.pt, aes(x = log(Po_NaHCO3_mg_kg), y = log(umol_pNP_g_h))) +
  geom_point(aes(color = site)) +
  stat_smooth(method = "lm",
              formula = y ~ x)

ggplot(data = all.pt, aes(x = log(Pi_NaOH_mg_kg), y = log(umol_pNP_g_h))) +
  geom_point(aes(color = site)) +
  stat_smooth(method = "lm",
              formula = y ~ x)

ggplot(data = all.pt, aes(x = log(Po_NaOH_mg_kg), y = log(umol_pNP_g_h))) +
  geom_point(aes(color = site)) +
  stat_smooth(method = "lm",
              formula = y ~ x)

# fractions ~ available PO4(3-)

ggplot(data = all.pt, aes(x = log(Pi_NaHCO3_mg_kg), y = log(P_mg_kg))) +
  geom_point(aes(color = site)) +
  stat_smooth(method = "lm",
              formula = y ~ x)

ggplot(data = all.pt, aes(x = log(Po_NaHCO3_mg_kg), y = log(P_mg_kg))) +
  geom_point(aes(color = site)) +
  stat_smooth(method = "lm",
              formula = y ~ x)

ggplot(data = all.pt, aes(x = log(Pi_NaOH_mg_kg), y = log(P_mg_kg))) +
  geom_point(aes(color = site)) +
  stat_smooth(method = "lm",
              formula = y ~ x)

ggplot(data = all.pt, aes(x = log(Po_NaOH_mg_kg), y = log(P_mg_kg))) +
  geom_point(aes(color = site)) +
  stat_smooth(method = "lm",
              formula = y ~ x)

```
### P ~ Po-NaHCO3 negative



## PME ~ Pi


```{r}

all$P_mg_kg_log <- log(all$P_mg_kg)
all$PME_log <- log(all$umol_pNP_g_h)

hist(all$P_mg_kg_log)
hist(all$PME_log)


p.pme <- ggplot(data = all, aes(x = P_mg_kg_log, y = log(umol_pNP_g_h))) +
  geom_point()

# no nested effects
mod1 <- lm(PME_log ~ P_mg_kg_log, data = all)
summary(mod1)
plot(mod1)
cor.test(all$P_mg_kg_log, all$PME_log, method = 'pearson')
## without nested effects, correlation is positive 0.37

p.pme +
  geom_line(data = fortify(mod1), aes(y = .fitted, x = P_mg_kg_log))

mod2 <- lm(PME_log ~ P_mg_kg_log*site, data = all)
summary(mod2)
plot(mod2)

mod3 <- lm(PME_log ~ P_mg_kg_log + site, data = all)
summary(mod3)
plot(mod3)

mod3b <- lm(PME_log ~ P_mg_kg + site, data = all)
summary(mod3b)
plot(mod3b)
ggplot(all, aes(x = P_mg_kg, y = PME_log)) +
  geom_point(aes(color = site)) +
  geom_line(data = fortify(mod3b), aes(x = P_mg_kg, y = .fitted)) +
  facet_wrap(~site)

mod3c <- lm(PME_log ~ site, data = all)
summary(mod3c)
plot(mod3c)
ggplot(all, aes(x = site, y = umol_pNP_g_h)) +
  geom_point(aes(color = site)) +
  geom_line(data = fortify(mod3c), aes(x = site, y = .fitted))

AIC(mod1, mod2, mod3, mod3b, mod3c)

# add nested random effects
mod4 <- lmer(PME_log ~ P_mg_kg + (1|site), data = all)
mod4 <- nlme::lme(PME_log ~ P_mg_kg, random = ~ 1|site, data = all)
summary(mod4)
anova(mod4)
## with nested effects, correlation between fixed effects
## is -0.52!

plot.lme(mod4)
# don't understand how fixed effect is positive 0.19???
fixef(mod4) # inter = 2.70, slope = 0.19
ranef(mod4)

mod5 <- lmer(PME_log ~ P_mg_kg + (1|site/tree), data = all)
mod5 <- nlme::lme(PME_log ~ P_mg_kg, random = ~ 1|site/tree, data = all)
summary(mod5)
anova(mod5)

mod6 <- lmer(PME_log ~ P_mg_kg + (1|site) + (1|tree), data = all)
summary(mod6)
anova(mod6)

AIC(mod1, mod2, mod3, mod3b, mod3c, mod4, mod5)

summary(mod3)

# mod3 looks best
# but P_mg_kg isn't significant? only site S, so it's just different in site S?


ggplot(all, aes(x = P_mg_kg_log, y = PME_log)) +
  geom_point(aes(color = site)) +
  geom_line(data = fortify(mod3), aes(x = P_mg_kg_log, y = .fitted)) +
  facet_wrap(~site)




```



# Delete later?

```{r}

hist(all$P_mg_kg)
hist(log(all$P_mg_kg))
all$P.log <- log(all$P_mg_kg)

hist(all$umol_pNP_g_h)
hist(log(all$umol_pNP_g_h))
all$PME.log <- log(all$umol_pNP_g_h)

ggplot(data = all, aes(x = log(P_mg_kg), y = log(umol_pNP_g_h), color = site)) +
  geom_point() +
  stat_smooth(method = "lm",
              formula = y ~ x)

## check for variable normality and that scales are similar (if not z-transform)


## only fixed effects

m0 <- lm(PME.log ~ P.log, data = all)

# plot residuals against potential random effects >> trends?

E <- rstandard(m0)
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects models with varying random structures

# random intercept

m1 <- lme4::lmer(PME.log ~ P.log + (1|site), all, REML = F)

# random slope

m2 <- lme4::lmer(PME.log ~ P.log + (1+P.log|site), all, REML = F)

m3 <- lme4::lmer(PME.log ~ P.log + (1+P.log||site), all, REML = F)

# nested

m4 <- lme4::lmer(PME.log ~ P.log + (1|site/tree), all, REML = F)

m5 <- lme4::lmer(PME.log ~ P.log + (1+P.log|site/tree), all, REML = F)

m6 <- lme4::lmer(PME.log ~ P.log + (1+P.log||site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m1, m2, m3, m4, m5, m6)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## compare best models, now using REML 

m1 <- lme4::lmer(PME.log ~ P.log + (1|site), all, REML = T)

m4 <- lme4::lmer(PME.log ~ P.log + (1|site/tree), all, REML = T)

m5 <- lme4::lmer(PME.log ~ P.log + (1+P.log|site/tree), all, REML = T)

MuMIn::model.sel(m4, m5, m1)[ , c("df", "logLik", "AICc", "delta")]
  ## nested site/tree is the best model (m4)

## continue model validation

# general bias or scedasticity 

plot(resid(m4) ~ fitted(m4), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence from other covariates

  # dependent variable
plot(resid(m4) ~ all$P.log, xlab = "log P mg/kg", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m4) ~ all$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m4))) +
  geom_point() +
  facet_wrap(~site) +
  geom_abline(slope = 0, intercept = 0)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m4))

## analyze the model!

(summary.m4 <- summary(m4))

estimate <- 0.4206
upper.ci <- 0.4206 + 1.96*0.3515
lower.ci <- 0.4206 - 1.96*0.3515

lower.ci

# not significantly different from 0

```

## Look into NH4 ~ SRL! by site

```{r}

## check for variable normality and that scales are similar (if not z-transform)

hist(all$mg_N.NH4_kg_dry_soil)
all$NH4.log <- log(all$mg_N.NH4_kg_dry_soil)
hist(all$NH4.log)

hist(all$SRL_m_g)
all$SRL.log <- log(all$SRL_m_g)
hist(all$SRL.log)

## only fixed effects

m0 <- lm(SRL.log ~ NH4.log, data = all)

# plot residuals against potential random effects >> trends?

E <- rstandard(m0)
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects models with varying random structures

# random intercept

m1 <- lme4::lmer(SRL.log ~ NH4.log + (1|site), all, REML = F)

# random slope

m2 <- lme4::lmer(SRL.log ~ NH4.log + (-1+NH4.log|site), all, REML = F)

# slope and intercept

m3 <- lme4::lmer(SRL.log ~ NH4.log + (1+NH4.log|site), all, REML = F)

# nested

m4 <- lme4::lmer(SRL.log ~ NH4.log + (1|site/tree), all, REML = F)

m5 <- lme4::lmer(SRL.log ~ NH4.log + (-1+NH4.log|site/tree), all, REML = F)

m6 <- lme4::lmer(SRL.log ~ NH4.log + (1+NH4.log|site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m1, m2, m3, m4, m5, m6)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## compare best models, now using REML 

m4 <- lme4::lmer(SRL.log ~ NH4.log + (1|site/tree), all, REML = F)

m0 <- lm(SRL.log ~ NH4.log, data = all)

MuMIn::model.sel(m4, m0)[ , c("df", "logLik", "AICc", "delta")]

m4 <- lme4::lmer(SRL.log ~ NH4.log + (1|site/tree), all, REML = T)

m1 <- lme4::lmer(SRL.log ~ NH4.log + (1|site), all, REML = T)

MuMIn::model.sel(m4, m1)[ , c("df", "logLik", "AICc", "delta")]
  ## nested site/tree is the best model

## continue model validation

# general bias or scedasticity 

plot(resid(m4) ~ fitted(m4), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence from other covariates

  # dependent variable
plot(resid(m4) ~ all$NH4.log, xlab = "log NH4 mg/kg", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m4) ~ all$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m4))) +
  geom_point() +
  facet_wrap(~site) +
  geom_abline(slope = 0, intercept = 0)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m4))

(summary.m4 <- summary(m4))

estimate <- -0.1188
lower.ci <- estimate - 1.96*0.068
upper.ci <- estimate + 1.96*0.068

(lower.ci)
(upper.ci)

# not significant

ggplot(aes(x = NH4.log, y = SRL.log), data = all) +
  geom_point()




```

 
## Look into RESP ~ SRL by site

```{r}

## check for variable normality and that scales are similar (if not z-transform)

hist(all$resp_ug_g_min)
all$resp.log <- log(all$resp_ug_g_min)
hist(all$resp.log)

hist(all$SRL_m_g)
all$SRL.log <- log(all$SRL_m_g)
hist(all$SRL.log)

## only fixed effects

m0 <- lm(resp.log ~ SRL.log, data = all)

# plot residuals against potential random effects >> trends?

E <- resid(m0) 
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects models with varying random structures
# nested

m4 <- lme4::lmer(resp.log ~ SRL.log + (1|site/tree), all, REML = F)

m5 <- lme4::lmer(resp.log ~ SRL.log + (-1+SRL.log|site/tree), all, REML = F)

m6 <- lme4::lmer(resp.log ~ SRL.log + (1+SRL.log|site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m4, m5, m6)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## compare best models, now using REML 

m4 <- lme4::lmer(resp.log ~ SRL.log + (1|site/tree), all, REML = T)

m5 <- lme4::lmer(resp.log ~ SRL.log + (-1+SRL.log|site/tree), all, REML = T)

m6 <- lme4::lmer(resp.log ~ SRL.log + (1+SRL.log|site/tree), all, REML = T)

MuMIn::model.sel(m4, m5, m6)[ , c("df", "logLik", "AICc", "delta")]
  
## nested site/tree is the best model
## model 4 and 5 have similar AIC (delta = 0.1)

summary(m4)
summary(m6)
summary(m5) # m5 has fewer df and slope is more obviously sign.

## continue model validation on m4

# general bias or scedasticity 

plot(resid(m5) ~ fitted(m5), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence dependent variables

plot(resid(m5) ~ all$SRL.log, xlab = "log NH4 mg/kg", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m5) ~ all$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m5))) +
  geom_point() +
  facet_wrap(~site) +
  geom_abline(slope = 0, intercept = 0)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m5))

(summary.m5 <- summary(m5))

slope <- coef(summary(m5))[2, 1]
sd <- coef(summary(m5))[2, 2]
lower.ci <- slope - 1.96*sd
upper.ci <- slope + 1.96*sd

(lower.ci)
(upper.ci)

# significant but negative correlation???????????????????????????????????????

ggplot(all, aes(x= SRL.log, y = resp.log, color = site)) +
  geom_point() +
  scale_color_manual(values = pal3) + 
  geom_abline(intercept = summary.m5$coefficients[1,
    1], slope = summary.m5$coefficients[2, 1]) +
  facet_wrap(~site + tree)

site.coef <- coef(m5)$site
colnames(site.coef) <- c("Intercept", "Slope")
tree.site.coef <- coef(m5)$`tree:site`
colnames(tree.site.coef) <- c("Intercept", "Slope")

# global model with sites
ggplot(all, aes(x= SRL.log, y = resp.log, color = site)) +
  geom_point() +
  scale_color_manual(values = pal3) + 
  geom_abline(intercept = summary.m5$coefficients[1,
    1], slope = summary.m5$coefficients[2, 1]) +
  geom_abline(intercept = site.coef[1, 1],
    slope = site.coef[1, 2], col = pal3[1]) + 
  geom_abline(intercept = site.coef[2,
    1], slope = site.coef[2, 2], col = pal3[2]) + 
  geom_abline(intercept = site.coef[3,
    1], slope = site.coef[3, 2], col = pal3[3])

```


## Look into RESP ~ NH4 by site

```{r}

## check for variable normality and that scales are similar (if not z-transform)

hist(all$mg_N.NH4_kg_dry_soil)
all$NH4.log <- log(all$mg_N.NH4_kg_dry_soil)
hist(all$NH4.log)

hist(all$SRL_m_g)
all$SRL.log <- log(all$SRL_m_g)
hist(all$SRL.log)

## only fixed effects

m0 <- lm(SRL.log ~ NH4.log, data = all)

# plot residuals against potential random effects >> trends?

E <- resid(m0) 
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects models with varying random structures

# random intercept

m1 <- lme4::lmer(SRL.log ~ NH4.log + (1|site), all, REML = F)

# random slope

m2 <- lme4::lmer(SRL.log ~ NH4.log + (-1+NH4.log|site), all, REML = F)

# slope and intercept

m3 <- lme4::lmer(SRL.log ~ NH4.log + (1+NH4.log|site), all, REML = F)

# nested

m4 <- lme4::lmer(SRL.log ~ NH4.log + (1|site/tree), all, REML = F)

m5 <- lme4::lmer(SRL.log ~ NH4.log + (-1+NH4.log|site/tree), all, REML = F)

m6 <- lme4::lmer(SRL.log ~ NH4.log + (1+NH4.log|site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m1, m2, m3, m4, m5, m6)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## compare best models, now using REML 

m4 <- lme4::lmer(SRL.log ~ NH4.log + (1|site/tree), all, REML = T)

m5 <- lme4::lmer(SRL.log ~ NH4.log + (-1+NH4.log|site/tree), all, REML = T)

MuMIn::model.sel(m4, m5)[ , c("df", "logLik", "AICc", "delta")]
  
## nested site/tree is the best model
## model 4 and 5 have similar AIC (delta = 0.1)

summary(m4) # m4 slope is just significant
summary(m5) # m5 slope in non-significant

## continue model validation on m4

# general bias or scedasticity 

plot(resid(m4) ~ fitted(m4), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence dependent variables

plot(resid(m4) ~ all$NH4.log, xlab = "log NH4 mg/kg", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m4) ~ all$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m4))) +
  geom_point() +
  facet_wrap(~site)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m4))

(summary.m4 <- summary(m4))

slope <- coef(summary(m4))[2, 1]
sd <- coef(summary(m4))[2, 2]
lower.ci <- slope - 1.96*sd
upper.ci <- slope + 1.96*sd

(lower.ci)
(upper.ci)

# not significant (crosses 0)



```


## Look into RESP ~ NH4 by site

```{r}

## check for variable normality and that scales are similar (if not z-transform)

hist(all$resp_ug_g_min)
all$resp.log <- log(all$resp_ug_g_min)
hist(all$resp.log)

hist(all$mg_N.NH4_kg_dry_soil)
all$NH4.log <- log(all$mg_N.NH4_kg_dry_soil)
hist(all$NH4.log)

## only fixed effects

m0 <- lm(resp.log ~ NH4.log, data = all)

# plot residuals against potential random effects >> trends?

E <- resid(m0) 
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects models with varying random structures
# nested

m4 <- lme4::lmer(resp.log ~ NH4.log + (1|site/tree), all, REML = F)

m5 <- lme4::lmer(resp.log ~ NH4.log + (-1+NH4.log|site/tree), all, REML = F)

m6 <- lme4::lmer(resp.log ~ NH4.log + (1+NH4.log|site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m4, m5, m6)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## compare best models, now using REML 

m4 <- lme4::lmer(resp.log ~ NH4.log + (1|site/tree), all, REML = T)

m5 <- lme4::lmer(resp.log ~ NH4.log + (-1+NH4.log|site/tree), all, REML = T)

MuMIn::model.sel(m4, m5)[ , c("df", "logLik", "AICc", "delta")]
  
## nested site/tree is the best model
## model 4 and 5 have similar AIC (delta = 0.1)

summary(m4) # m4 slope is just significant
summary(m5) # m5 slope in non-significant

## continue model validation on m4

# general bias or scedasticity 

plot(resid(m4) ~ fitted(m4), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence dependent variables

plot(resid(m4) ~ all$NH4.log, xlab = "log NH4 mg/kg", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m4) ~ all$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m4))) +
  geom_point() +
  facet_wrap(~site) +
  geom_abline(slope = 0, intercept = 0)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m4))

(summary.m4 <- summary(m4))

slope <- coef(summary(m4))[2, 1]
sd <- coef(summary(m4))[2, 2]
lower.ci <- slope - 1.96*sd
upper.ci <- slope + 1.96*sd

(lower.ci)
(upper.ci)

# not significant (crosses 0)



```



## PME and MYC

```{r}
# semilog plot 
ggplot(all, aes(x=PME.log, y = myc_percent, color = site)) +
  geom_point()

# removing high values makes the relationship clearer but non-sign
# try with GLM to account for strong skew in PME data


## check for variable normality and that scales are similar (if not z-transform)
hist(all$umol_pNP_g_h)
hist(all$PME.log)
hist(all$myc_percent)

# # z tranform both variables
# 
# all$PME.log.z <- scale(all$PME.log)
# all$myc.z <- scale(all$myc_percent)

## only fixed effects

m0 <- lm(PME.log ~ myc_percent, data = all)

# plot residuals against potential random effects >> trends?

E <- rstandard(m0)
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects nested models with varying random structures

# nested

m1.1 <- lme4::lmer(PME.log ~ myc_percent + (1|site), all, REML = F)

m1 <- lme4::lmer(PME.log ~ myc_percent + (1|site/tree), all, REML = F)

m2 <- lme4::lmer(PME.log ~ myc_percent + (-1 + myc_percent|site/tree), all, REML = F)

m3 <- lme4::lmer(PME.log ~ myc_percent + (1 + myc_percent|site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m1.1, m1, m2, m3)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## compare best models, now using REML 

m1 <- lme4::lmer(PME.log ~ myc_percent + (1|site/tree), all, REML = T)

m3 <- lme4::lmer(PME.log ~ myc_percent + (1 + myc_percent|site/tree), all, REML = T)


MuMIn::model.sel(m1, m3)[ , c("df", "logLik", "AICc", "delta")]

# m1 is best

## continue model validation

# general bias or scedasticity 

plot(resid(m1) ~ fitted(m1), xlab = "Predicted values", ylab = "Residuals")
abline(h = 0, lty = 2)

# check residual independence from other covariates

  # dependent variable
plot(resid(m1) ~ all$myc_percent, xlab = "M%", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m1) ~ all$site, xlab = "sites", ylab = "Residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m1))) +
  geom_point() +
  facet_wrap(~site) +
  geom_abline(slope = 0, intercept = 0)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m1))

(summary.m1 <- summary(m1))

slope <- coef(summary(m1))[2, 1]
sd <- coef(summary(m1))[2, 2]
lower.ci <- slope - 1.96*sd
upper.ci <- slope + 1.96*sd

(lower.ci)
(upper.ci)

# not significant

plot(resid(m1) ~ fitted(m1), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)


```

## M% ~ P

```{r}


## check for variable normality and that scales are similar (if not z-transform)

cor(x = all$P.log, y = all$myc_percent, method = "pearson")


hist(all$P.log)

hist(all$myc_percent)

## only fixed effects

m0 <- lm(myc_percent ~ P.log, data = all)

# plot residuals against potential random effects >> trends?

E <- resid(m0)
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects models with varying random structures

# intercept

m1 <- lme4::lmer(myc_percent ~ P.log + (1|site/tree), all, REML = F)

# slope

m2 <- lme4::lmer(myc_percent ~ P.log + (-1+P.log|site/tree), all, REML = F)

# slope and intercept

m3 <- lme4::lmer(myc_percent ~ P.log + (1+P.log|site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m1, m2, m3)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## again with REML

m1 <- lme4::lmer(myc_percent ~ P.log + (1|site/tree), all, REML = T)

m2 <- lme4::lmer(myc_percent ~ P.log + (-1+P.log|site/tree), all, REML = T)

AIC.table <- MuMIn::model.sel(m1, m2)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## continue model validation with m1 or m2

# general bias or scedasticity 

plot(resid(m2) ~ fitted(m2), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence from other covariates

  # dependent variables
plot(resid(m2) ~ all$P.log, xlab = "P.log", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m2) ~ all$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m2))) +
  geom_point() +
  facet_wrap(~site) +
  geom_abline(slope = 0, intercept = 0)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m2))

(summary.m2 <- summary(m2))
plot(resid(m2) ~ all$P.log)
plot(resid(m2) ~ all$site)
plot(fitted(m2) ~ resid(m2))

slope <- coef(summary(m2))[2, 1]
sd <- coef(summary(m2))[2, 2]
lower.ci <- slope - 1.96*sd
upper.ci <- slope + 1.96*sd

(lower.ci)
(upper.ci)

# significant?!

coef(m2)
ranef(m2)

ggplot(data = all, aes(x = P.log, y = myc_percent)) +
  geom_point() +
  facet_wrap(~site + tree)

site.coef <- coef(m2)$site
colnames(site.coef) <- c("Intercept", "Slope")
tree.site.coef <- coef(m5)$`tree:site`
colnames(tree.site.coef) <- c("Intercept", "Slope")

# # global model with sites
# ggplot(all, aes(x= SRL.log, y = resp.log, color = site)) +
#   geom_point() +
#   scale_color_manual(values = pal3) + 
#   geom_abline(intercept = summary.m5$coefficients[1,
#     1], slope = summary.m5$coefficients[2, 1]) +
#   geom_abline(intercept = site.coef[1, 1],
#     slope = site.coef[1, 2], col = pal3[1]) + 
#   geom_abline(intercept = site.coef[2,
#     1], slope = site.coef[2, 2], col = pal3[2]) + 
#   geom_abline(intercept = site.coef[3,
#     1], slope = site.coef[3, 2], col = pal3[3])

```

## Look into MYC (90) ~ CEC (30)

```{r}


## check for variable normality and that scales are similar (if not z-transform)

cor(x = all$CEC_cmol_kg, y = all$myc_percent, method = "pearson")


hist(all$CEC_cmol_kg)

hist(all$myc_percent)

## only fixed effects

m0 <- lm(myc_percent ~ CEC_cmol_kg, data = all)
# m0.p <- lm(myc_percent ~ CEC_cmol_kg +P.log, data = all)

# plot residuals against potential random effects >> trends?

E <- resid(m0)
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects models with varying random structures

# intercept

m1 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (1|site/tree), all, REML = F)

# slope

m2 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (-1+CEC_cmol_kg|site/tree), all, REML = F)

# slope and intercept

m3 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (1+CEC_cmol_kg|site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m1, m2, m3)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## again with REML

m1 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (1|site/tree), all, REML = T)

m2 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (-1+CEC_cmol_kg|site/tree), all, REML = T)

AIC.table <- MuMIn::model.sel(m1, m2)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## continue model validation with m1

# general bias or scedasticity 


plot(resid(m1) ~ fitted(m1), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence from other covariates

  # dependent variables
plot(resid(m1) ~ all$CEC_cmol_kg, xlab = "CEC", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m1) ~ all$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m1))) +
  geom_point() +
  facet_wrap(~site) +
  geom_abline(slope = 0, intercept = 0)

## check residual normality
hist(resid(m1))

summary(m1)

slope <- coef(summary(m1))[2, 1]
sd <- coef(summary(m1))[2, 2]
lower.ci <- slope - 1.96*sd
upper.ci <- slope + 1.96*sd

(lower.ci)
(upper.ci)

# significant?!

coef(m1)
ranef(m1)


# CEC & individual cations

(CEC <- ggplot(all, aes(x = CEC_cmol_kg, y = myc_percent, 
                color = site)) +
  geom_point(aes(size = 3)) +
  scale_color_manual(values = pal3) +
  labs(x = "Cation Exchange Capacity (cmol/kg)",
       y = "Mycorrhizal Colonization (%)") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20)))

png("output/CEC.MYC_2023-08-07.png", height = 8, width = 12, unit = "in", res = 800)
print(CEC)
dev.off()

ggplot(all, aes(x = log(Mg_cmol_kg), y = myc_percent)) +
  geom_point(aes(color = site)) +
  scale_color_manual(values = pal3) +
  stat_smooth(formula = y ~ x, method = "loess")

ggplot(all, aes(x = log(Mg_cmol_kg), y = log(umol_pNP_g_h))) +
  geom_point(aes(color = site)) +
  scale_color_manual(values = pal3) +
  stat_smooth(formula = y ~ x, method = "loess")

  # potential relationship, potentially non-linear with Mg

ggplot(all, aes(x = log(Ca_cmol_kg), y = myc_percent, color = site)) +
  geom_point() +
  scale_color_manual(values = pal3)

  # potential linear relationship with Ca

ggplot(all, aes(x = K_cmol_kg, y = myc_percent)) +
  geom_point(aes(color = site)) +
  scale_color_manual(values = pal3)+
  stat_smooth(formula = y ~ x, method = "loess")

  # no apparent relationship with K

```

## MYC~CEC averaged to tree level (roots)

```{r}

temp <- all %>%
  select(site, tree, root, CEC_cmol_kg, myc_percent) %>%
  group_by(site, tree) %>%
  dplyr::summarise(across(where(is.numeric), .fns = ~mean(.))) %>%
  dplyr::mutate(across(where(is.numeric), .fns = ~round(., 1)))

str(temp)

## check for variable normality and that scales are similar (if not z-transform)


hist(temp$CEC_cmol_kg)

hist(temp$myc_percent)

## only fixed effects

m0 <- lm(myc_percent ~ CEC_cmol_kg, data = temp)

# plot residuals against potential random effects >> trends?

E <- resid(m0)
plot(E ~ site, temp)
abline(0, 0)

## fit mixed effects models with varying random structures

# intercept

m1 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (1|site), temp, REML = F)

# slope

m2 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (-1+CEC_cmol_kg|site), temp, REML = F)

# slope and intercept

m3 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (1+CEC_cmol_kg|site), temp, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m1, m2, m3)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## again with REML

m1 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (1|site), temp, REML = T)

# 
# m2 <- lme4::lmer(myc_percent ~ CEC_cmol_kg + (-1+CEC_cmol_kg|site), temp, REML = T)
# 
# AIC.table <- MuMIn::model.sel(m1, m2)
# 
# (AIC.table[ , c("df", "logLik", "AICc", "delta")])

## continue model validation with m1

# general bias or scedasticity 

plot(resid(m1) ~ fitted(m1), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence from other covariates

  # dependent variables
plot(resid(m1) ~ temp$CEC_cmol_kg, xlab = "CEC", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m1) ~ temp$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

#   # tree in site

ggplot(temp, aes(x = CEC_cmol_kg, y = myc_percent, color = site)) +
  geom_point() +
  geom_abline(slope = 0, intercept = 0)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m1))

(summary.m1 <- summary(m1))

slope <- coef(summary(m1))[2, 1]
sd <- coef(summary(m1))[2, 2]
lower.ci <- slope - 1.96*sd
upper.ci <- slope + 1.96*sd

(lower.ci)
(upper.ci)

# significant?!

coef(m1)
ranef(m1)


  

```




## Look into CEC ~ RTD 

```{r}

## check for variable normality and that scales are similar (if not z-transform)

hist(all$CEC_cmol_kg)

hist(all$RTD_g_cm3)

all$CEC.z <- scale(all$CEC_cmol_kg)
all$RTD.z <- scale(all$RTD_g_cm3)

## only fixed effects

m0 <- lm(RTD.z ~ CEC.z, data = all)

# plot residuals against potential random effects >> trends?

E <- rstandard(m0)
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects models with varying random structures

# random intercept

m1 <- lme4::lmer(RTD.z ~ CEC.z + (1|site), all, REML = F)

# random slope

m2 <- lme4::lmer(RTD.z ~ CEC.z + (-1+CEC.z|site), all, REML = F)

# slope and intercept

m3 <- lme4::lmer(RTD.z ~ CEC.z + (1+CEC.z|site), all, REML = F)

# nested

m4 <- lme4::lmer(RTD.z ~ CEC.z + (1|site/tree), all, REML = F)

m5 <- lme4::lmer(RTD.z ~ CEC.z + (-1+CEC.z|site/tree), all, REML = F)

m6 <- lme4::lmer(RTD.z ~ CEC.z + (1+CEC.z|site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m1, m2, m3, m4, m5, m6)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## simple linear model is best

m0 <- lm(RTD.z ~ CEC.z, data = all)

## continue model validation

# general bias or scedasticity 

plot(resid(m0) ~ fitted(m0), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence from other covariates

  # dependent variable
plot(resid(m0) ~ all$CEC.z, xlab = "CEC z", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m0) ~ all$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m0))) +
  geom_point() +
  facet_wrap(~site) +
  geom_abline(slope = 0, intercept = 0)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m0))

(summary.m0 <- summary(m0))

```

## Look into CEC ~ SRL 

```{r, eval = FALSE}

## check for variable normality and that scales are similar (if not z-transform)

hist(all$CEC.log)

hist(all$SRL.log)


## only fixed effects

m0 <- lm(SRL.z ~ CEC.z, data = all)

# plot residuals against potential random effects >> trends?

E <- rstandard(m0)
plot(E ~ site, all)
abline(0, 0)

## fit mixed effects models with varying random structures

# random intercept

m1 <- lme4::lmer(SRL.z ~ CEC.z + (1|site), all, REML = F)

# random slope

m2 <- lme4::lmer(SRL.z ~ CEC.z + (-1+CEC.z|site), all, REML = F)

# slope and intercept

m3 <- lme4::lmer(SRL.z ~ CEC.z + (1+CEC.z|site), all, REML = F)

# nested

m4 <- lme4::lmer(SRL.z ~ CEC.z + (1|site/tree), all, REML = F)

m5 <- lme4::lmer(SRL.z ~ CEC.z + (-1+CEC.z|site/tree), all, REML = F)

m6 <- lme4::lmer(SRL.z ~ CEC.z + (1+CEC.z|site/tree), all, REML = F)

## compare models

AIC.table <- MuMIn::model.sel(m0, m1, m2, m3, m4, m5, m6)

(AIC.table[ , c("df", "logLik", "AICc", "delta")])

## simple linear model is best

MuMIn::model.sel(m4, m0, m1)[ , c("df", "logLik", "AICc", "delta")]

m4 <- lme4::lmer(SRL.z ~ CEC.z + (1|site/tree), all, REML = T)

## continue model validation

# general bias or scedasticity 

plot(resid(m4) ~ fitted(m4), xlab = "Predicted values", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

# check residual independence from other covariates

  # dependent variable
plot(resid(m4) ~ all$CEC.z, xlab = "CEC z", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # site
plot(resid(m4) ~ all$site, xlab = "sites", ylab = "Normalized residuals")
abline(h = 0, lty = 2)

  # tree in site
ggplot(all, aes(x = tree, y = resid(m4))) +
  geom_point() +
  facet_wrap(~site) +
  geom_abline(slope = 0, intercept = 0)

## NOW, plot residuals against variables not included in the model
## perhaps to add to the model

## check residual normality

hist(resid(m0))

(summary.m0 <- summary(m0))

```



## SRL ~ RESP

Trying to add nested structure to models.

Will try by using LME with random nested effects of site/tree/root

Adding nested structure didn't change resp~SRL relationship much, but I didn't fully validate the model. Residuals weren't bad to begin with though. 

*Not sure how to interpret lme output and graph on ggplot

*consider removing some high respiration values (raw > 40), in S/P site

```{r}

root <- root %>%
  mutate(resp_log = log(resp_ug_g_min)) %>%
  mutate(SRL_log = log(SRL_m_g)) %>%
  mutate(PME_log = log(umol_pNP_g_h))

## Respiration ~ SRL

# Create the model (no spatial autocorrelation included)
fit <- lm(resp_log ~ SRL_log, data = root)
summary(fit)
plot(fit)
cor.test(root$SRL_log, root$resp_log, method = 'pearson')
# pearson's r = 0.72, decent residuals

# Add site as interacting factor
fitb <- lm(resp_log ~ SRL_log*site, data = root)
summary(fitb)
plot(fitb)

# add site (not interacting)
fitc <- lm(resp_log ~ SRL_log + site, data = root)
summary(fitc)
plot(fitc)

AIC(fit, fitb, fitc)

# continue with fitb?

# check if model is homoscedastic

E <- resid(fitb)
hist(E)
plot(E ~ site, data = root)
plot(E ~ SRL_log, data = root)
coplot(E ~ SRL_log | site, data = root)

summary(fitb)

# fitb has a adj R2 = 0.61 (higher than simpler models), and lowest AIC
# global model sign., intercept, SRL slope, siteS, and SRL*siteS also sign.

ggplot(root, aes(x = SRL_log, y = resp_log)) +
  geom_point(aes(color = site)) +
  geom_line(data = fortify(fitb), aes(x = SRL_log, y = .fitted))

fitd <- lm(resp_log ~ SRL_log, data = root %>% filter(resp_ug_g_min < 50))
AIC(fit, fitb, fitc, fitd)

# if I take out values over 40, AIC gets pretty close to fitb!
# but R2 goes way down!
summary(fitd)

```


*Should I only use site and tree as nested factors? Is root implied?*

```{r}

# add nested sample structure
fite <- lme(resp_log ~ SRL_log, data = root, random = ~1 |site/tree)
summary(fite)
plot(fite)

fitf <- lme(resp_log ~ SRL_log*site, data = root, random = ~1|site/tree)
summary(fitf)
plot(fitf)

AIC(fit, fitb, fitc, fitd, fite, fitf)

plot.lme(fitf)

# how to validate? fitb still seems like the best
# but using AIC on such different models seems bad

ggplot(root, aes(x = SRL_log, y = resp_log)) +
  geom_point(aes(color = site)) +
  facet_wrap(~site) +
  geom_line(data = fortify(fitb), aes(x = SRL_log, y = .fitted)) +
  labs(x = "Log Specific Root Length (m/g)",
        y = "Log Respiration Rate (ug CO2/g/min)") 

# it looks good graphed!!!

fitg <- lmer(resp_log ~ SRL_log*site + (1|site/tree), data = root)
summary(fitg)
plot.lme(fitg)
qqmath(fitg)
AIC(fitf, fitg)

# Try these lines to graph models:
# ggplot(data = broom::augment(mod1, se_fit = TRUE), 
  # augment (broom::) pulls slopes and se from model
#        mapping = aes(x = SRL_log, colour = site)) +
#   geom_point(mapping = aes(y = PME_log)) +
#   geom_line(mapping = aes(y = .fitted)) +
#   geom_ribbon(mapping = aes(y = .fitted,
#                             ymax = (.fitted + .se.fit),
#                             ymin = (.fitted - .se.fit),
#                             fill = type),
#               linetype = 0, alpha = 0.5) +
#   facet_wrap(~ site)

```